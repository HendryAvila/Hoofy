package tools

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/HendryAvila/Hoofy/internal/templates"
	"github.com/mark3labs/mcp-go/mcp"
)

// --- BootstrapTool tests ---

// setupBootstrapProject creates a temp dir with an sdd/ directory,
// changes cwd to it. Returns the root and cleanup.
func setupBootstrapProject(t *testing.T) (string, func()) {
	t.Helper()
	dir := t.TempDir()

	if err := os.MkdirAll(filepath.Join(dir, "sdd"), 0o755); err != nil {
		t.Fatalf("setup: mkdir sdd: %v", err)
	}

	origDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("setup: getwd: %v", err)
	}
	if err := os.Chdir(dir); err != nil {
		t.Fatalf("setup: chdir: %v", err)
	}

	cleanup := func() { _ = os.Chdir(origDir) }
	return dir, cleanup
}

func TestBootstrapTool_Definition(t *testing.T) {
	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)
	def := tool.Definition()

	if def.Name != "sdd_bootstrap" {
		t.Errorf("tool name = %q, want %q", def.Name, "sdd_bootstrap")
	}
	if def.Description == "" {
		t.Error("definition should have a description")
	}
}

func TestBootstrapTool_Handle_WriteAllThreeArtifacts(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have":      "- **FR-001**: Users can sign up",
		"requirements_should_have":    "- **FR-002**: Users can export data",
		"requirements_non_functional": "- **NFR-001**: Load time < 2s",
		"business_rules_definitions":  "- **User**: A person with an account",
		"business_rules_facts":        "- A User has one Account",
		"business_rules_constraints":  "- When password is wrong 3 times, lock account",
		"design_architecture":         "Monolith with Clean Architecture",
		"design_tech_stack":           "- Go 1.21\n- PostgreSQL 16",
		"design_components":           "### AuthModule\n- Handles login",
		"design_data_model":           "### User\n| id | UUID |",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("expected success, got error: %s", getResultText(result))
	}

	text := getResultText(result)

	// Should report all 3 written.
	if !strings.Contains(text, "requirements.md") {
		t.Error("should report requirements.md written")
	}
	if !strings.Contains(text, "business-rules.md") {
		t.Error("should report business-rules.md written")
	}
	if !strings.Contains(text, "design.md") {
		t.Error("should report design.md written")
	}
	if !strings.Contains(text, "Written") {
		t.Error("should have Written section")
	}

	// Verify files exist on disk.
	for _, name := range []string{"requirements.md", "business-rules.md", "design.md"} {
		path := filepath.Join(root, "sdd", name)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			t.Errorf("expected %s to exist on disk", name)
		}
	}

	// Verify auto-generated header in files.
	data, err := os.ReadFile(filepath.Join(root, "sdd", "requirements.md"))
	if err != nil {
		t.Fatalf("read requirements: %v", err)
	}
	if !strings.Contains(string(data), "Auto-generated by sdd_reverse_engineer") {
		t.Error("requirements.md should have auto-generated header")
	}
}

func TestBootstrapTool_Handle_WriteOnlyMissing(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	// Pre-create requirements.md and design.md.
	writeTestFile(t, root, "sdd/requirements.md", "# Existing Requirements\n\nAlready here.\n")
	writeTestFile(t, root, "sdd/design.md", "# Existing Design\n\nAlready here.\n")

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have":      "- FR-001: This should NOT be written",
		"requirements_should_have":    "- FR-002: Ignored",
		"requirements_non_functional": "- NFR-001: Ignored",
		"business_rules_definitions":  "- **Order**: A purchase request",
		"business_rules_facts":        "- An Order has Items",
		"business_rules_constraints":  "- When cart is empty, block checkout",
		"design_architecture":         "This should be IGNORED",
		"design_tech_stack":           "Ignored",
		"design_components":           "Ignored",
		"design_data_model":           "Ignored",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}

	text := getResultText(result)

	// Only business-rules should be written.
	if !strings.Contains(text, "business-rules.md") {
		t.Error("should write business-rules.md (the only missing one)")
	}

	// Requirements and design should be skipped.
	if !strings.Contains(text, "Skipped") {
		t.Error("should have Skipped section")
	}
	if !strings.Contains(text, "already exists") {
		t.Error("should mention already exists for skipped artifacts")
	}

	// Verify requirements.md was NOT overwritten.
	data, err := os.ReadFile(filepath.Join(root, "sdd", "requirements.md"))
	if err != nil {
		t.Fatalf("read requirements: %v", err)
	}
	if !strings.Contains(string(data), "Existing Requirements") {
		t.Error("requirements.md should NOT have been overwritten")
	}
	if strings.Contains(string(data), "This should NOT be written") {
		t.Error("requirements.md content was overwritten — should have been skipped")
	}

	// Verify business-rules.md was created.
	brData, err := os.ReadFile(filepath.Join(root, "sdd", "business-rules.md"))
	if err != nil {
		t.Fatalf("read business-rules: %v", err)
	}
	if !strings.Contains(string(brData), "Order") {
		t.Error("business-rules.md should contain the new content")
	}
}

func TestBootstrapTool_Handle_AllExist(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	// Pre-create all 3 artifacts.
	writeTestFile(t, root, "sdd/requirements.md", "# Requirements\nExisting\n")
	writeTestFile(t, root, "sdd/business-rules.md", "# Business Rules\nExisting\n")
	writeTestFile(t, root, "sdd/design.md", "# Design\nExisting\n")

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have":      "- FR-001: Something",
		"requirements_should_have":    "- FR-002: Something",
		"requirements_non_functional": "- NFR-001: Something",
		"business_rules_definitions":  "- Term: Def",
		"business_rules_facts":        "- Fact",
		"business_rules_constraints":  "- Constraint",
		"design_architecture":         "Arch",
		"design_tech_stack":           "Stack",
		"design_components":           "Components",
		"design_data_model":           "Model",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}

	text := getResultText(result)
	if !strings.Contains(text, "All artifacts already exist") {
		t.Error("should indicate all artifacts already exist")
	}
}

func TestBootstrapTool_Handle_NoContent(t *testing.T) {
	_, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	// No artifact content at all.
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if !isErrorResult(result) {
		t.Error("should return error when no content provided")
	}
	text := getResultText(result)
	if !strings.Contains(text, "No artifact content") {
		t.Errorf("error should mention no content: %s", text)
	}
}

func TestBootstrapTool_Handle_RequirementsOnly(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have":      "- **FR-001**: Users can register",
		"requirements_should_have":    "- **FR-002**: Users can reset password",
		"requirements_non_functional": "- **NFR-001**: 99.9% uptime",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("expected success, got error: %s", getResultText(result))
	}

	text := getResultText(result)
	if !strings.Contains(text, "requirements.md") {
		t.Error("should write requirements.md")
	}
	// Business rules and design should NOT appear.
	if strings.Contains(text, "business-rules.md") {
		t.Error("should not mention business-rules.md when no content provided")
	}
	if strings.Contains(text, "design.md") {
		t.Error("should not mention design.md when no content provided")
	}

	// Verify file exists.
	if _, err := os.Stat(filepath.Join(root, "sdd", "requirements.md")); os.IsNotExist(err) {
		t.Error("requirements.md should exist on disk")
	}

	// Verify auto-generated header.
	data, err := os.ReadFile(filepath.Join(root, "sdd", "requirements.md"))
	if err != nil {
		t.Fatalf("read: %v", err)
	}
	if !strings.Contains(string(data), autoGeneratedHeader[:20]) {
		t.Error("should have auto-generated header")
	}
}

func TestBootstrapTool_Handle_CustomProjectName(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"project_name":               "MyCustomProject",
		"business_rules_definitions": "- **Widget**: A thing",
		"business_rules_facts":       "- A Widget has a name",
		"business_rules_constraints": "- Name must be unique",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("unexpected error: %s", getResultText(result))
	}

	// Verify the project name is used in the artifact.
	data, err := os.ReadFile(filepath.Join(root, "sdd", "business-rules.md"))
	if err != nil {
		t.Fatalf("read: %v", err)
	}
	if !strings.Contains(string(data), "MyCustomProject") {
		t.Error("artifact should use the custom project name")
	}
}

func TestBootstrapTool_Handle_DefaultProjectName(t *testing.T) {
	root, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	dirName := filepath.Base(root)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"design_architecture": "Serverless with Lambda",
		"design_tech_stack":   "Python + DynamoDB",
		"design_components":   "### Handler\n- Processes events",
		"design_data_model":   "### Event\n| id | string |",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("expected success, got error: %s", getResultText(result))
	}

	// Verify the directory name is used in the artifact.
	data, err := os.ReadFile(filepath.Join(root, "sdd", "design.md"))
	if err != nil {
		t.Fatalf("read: %v", err)
	}
	if !strings.Contains(string(data), dirName) {
		t.Error("artifact should use directory name as default project name")
	}
}

func TestBootstrapTool_Handle_CreatesSddDir(t *testing.T) {
	// Use a directory WITHOUT a pre-existing sdd/ dir.
	dir := t.TempDir()
	origDir, _ := os.Getwd()
	if err := os.Chdir(dir); err != nil {
		t.Fatalf("chdir: %v", err)
	}
	defer func() { _ = os.Chdir(origDir) }()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"business_rules_definitions": "- **User**: A person",
		"business_rules_facts":       "- Users have IDs",
		"business_rules_constraints": "- IDs must be unique",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("expected success, got error: %s", getResultText(result))
	}

	// sdd/ directory should have been created.
	if _, err := os.Stat(filepath.Join(dir, "sdd")); os.IsNotExist(err) {
		t.Error("sdd/ directory should have been created")
	}
	if _, err := os.Stat(filepath.Join(dir, "sdd", "business-rules.md")); os.IsNotExist(err) {
		t.Error("business-rules.md should exist")
	}
}

func TestBootstrapTool_Handle_NextSteps(t *testing.T) {
	_, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have":      "- FR-001: Something",
		"requirements_should_have":    "- FR-002: Something",
		"requirements_non_functional": "- NFR-001: Something",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}

	text := getResultText(result)
	if !strings.Contains(text, "Next Steps") {
		t.Error("response should include next steps guidance")
	}
	if !strings.Contains(text, "sdd_change") {
		t.Error("next steps should mention sdd_change")
	}
}

func TestBootstrapTool_Handle_PartialRequirementsContent(t *testing.T) {
	_, cleanup := setupBootstrapProject(t)
	defer cleanup()

	renderer, _ := templates.NewRenderer()
	tool := NewBootstrapTool(renderer)

	// Provide only must_have — should fill defaults for should_have and non_functional.
	req := mcp.CallToolRequest{}
	req.Params.Arguments = map[string]interface{}{
		"requirements_must_have": "- **FR-001**: Users can sign up",
	}

	result, err := tool.Handle(context.Background(), req)
	if err != nil {
		t.Fatalf("Handle failed: %v", err)
	}
	if isErrorResult(result) {
		t.Fatalf("expected success, got error: %s", getResultText(result))
	}

	text := getResultText(result)
	if !strings.Contains(text, "requirements.md") {
		t.Error("should write requirements.md even with partial content")
	}
}
