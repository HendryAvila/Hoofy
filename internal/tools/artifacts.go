// Package tools — see helpers.go for package doc.
//
// artifacts.go provides shared rendering+writing functions for SDD artifacts.
// These are the core functions that both pipeline tools (with stage guards)
// and the bootstrap tool (without guards) use to generate and persist
// artifact files. This avoids duplication and ensures all paths produce
// identically formatted artifacts.
//
// ADR-001: Shared rendering functions over pipeline bypass for reverse engineer.
package tools

import (
	"fmt"

	"github.com/HendryAvila/Hoofy/internal/config"
	"github.com/HendryAvila/Hoofy/internal/templates"
)

// autoGeneratedHeader is prepended to artifacts created by the bootstrap tool.
const autoGeneratedHeader = "> ⚡ Auto-generated by sdd_reverse_engineer — review and refine as needed\n\n"

// RenderAndWriteRequirements renders requirements.md using the template
// and writes it to sdd/. Returns the rendered content.
// If autoGenerated is true, prepends the auto-generated header.
func RenderAndWriteRequirements(projectRoot string, renderer templates.Renderer, data templates.RequirementsData, autoGenerated bool) (string, error) {
	content, err := renderer.Render(templates.Requirements, data)
	if err != nil {
		return "", fmt.Errorf("rendering requirements: %w", err)
	}

	if autoGenerated {
		content = autoGeneratedHeader + content
	}

	path := config.StagePath(projectRoot, config.StageSpecify)
	if err := writeStageFile(path, content); err != nil {
		return "", fmt.Errorf("writing requirements: %w", err)
	}

	return content, nil
}

// RenderAndWriteBusinessRules renders business-rules.md using the template
// and writes it to sdd/. Returns the rendered content.
// If autoGenerated is true, prepends the auto-generated header.
func RenderAndWriteBusinessRules(projectRoot string, renderer templates.Renderer, data templates.BusinessRulesData, autoGenerated bool) (string, error) {
	content, err := renderer.Render(templates.BusinessRules, data)
	if err != nil {
		return "", fmt.Errorf("rendering business rules: %w", err)
	}

	if autoGenerated {
		content = autoGeneratedHeader + content
	}

	path := config.StagePath(projectRoot, config.StageBusinessRules)
	if err := writeStageFile(path, content); err != nil {
		return "", fmt.Errorf("writing business rules: %w", err)
	}

	return content, nil
}

// RenderAndWriteDesign renders design.md using the template
// and writes it to sdd/. Returns the rendered content.
// If autoGenerated is true, prepends the auto-generated header.
func RenderAndWriteDesign(projectRoot string, renderer templates.Renderer, data templates.DesignData, autoGenerated bool) (string, error) {
	content, err := renderer.Render(templates.Design, data)
	if err != nil {
		return "", fmt.Errorf("rendering design: %w", err)
	}

	if autoGenerated {
		content = autoGeneratedHeader + content
	}

	path := config.StagePath(projectRoot, config.StageDesign)
	if err := writeStageFile(path, content); err != nil {
		return "", fmt.Errorf("writing design: %w", err)
	}

	return content, nil
}

// ArtifactExists checks whether a specific SDD artifact file exists
// and is non-empty in the project's sdd/ directory.
func ArtifactExists(projectRoot string, stage config.Stage) bool {
	path := config.StagePath(projectRoot, stage)
	if path == "" {
		return false
	}
	data, err := readStageFile(path)
	if err != nil || data == "" {
		return false
	}
	return true
}

// CheckSDDArtifacts checks if any SDD artifacts exist in the project.
// Returns true if at least one of business-rules.md, requirements.md,
// or design.md exists and is non-empty.
func CheckSDDArtifacts(projectRoot string) bool {
	stages := []config.Stage{
		config.StageBusinessRules,
		config.StageSpecify,
		config.StageDesign,
	}
	for _, stage := range stages {
		if ArtifactExists(projectRoot, stage) {
			return true
		}
	}
	return false
}
