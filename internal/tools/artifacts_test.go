package tools

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/HendryAvila/Hoofy/internal/config"
	"github.com/HendryAvila/Hoofy/internal/templates"
)

// --- RenderAndWriteRequirements ---

func TestRenderAndWriteRequirements_Success(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.RequirementsData{
		Name:          "test-project",
		MustHave:      "- **FR-001**: Users can sign up",
		ShouldHave:    "- **FR-002**: Users can export data",
		NonFunctional: "- **NFR-001**: Load time < 2s",
	}

	content, err := RenderAndWriteRequirements(tmpDir, renderer, data, false)
	if err != nil {
		t.Fatalf("RenderAndWriteRequirements: %v", err)
	}

	// Verify content was returned.
	if !strings.Contains(content, "FR-001") {
		t.Error("returned content should contain FR-001")
	}
	if !strings.Contains(content, "Users can sign up") {
		t.Error("returned content should contain requirement text")
	}

	// Verify file was created.
	path := config.StagePath(tmpDir, config.StageSpecify)
	fileData, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("read file: %v", err)
	}
	if string(fileData) != content {
		t.Error("file content should match returned content")
	}

	// Verify NO auto-generated header.
	if strings.Contains(content, autoGeneratedHeader) {
		t.Error("should NOT have auto-generated header when autoGenerated=false")
	}
}

func TestRenderAndWriteRequirements_AutoGenerated(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.RequirementsData{
		Name:          "test-project",
		MustHave:      "- **FR-001**: Users can sign up",
		ShouldHave:    "- **FR-002**: Export data",
		NonFunctional: "- **NFR-001**: Fast",
	}

	content, err := RenderAndWriteRequirements(tmpDir, renderer, data, true)
	if err != nil {
		t.Fatalf("RenderAndWriteRequirements: %v", err)
	}

	// Verify auto-generated header is prepended.
	if !strings.HasPrefix(content, autoGeneratedHeader) {
		t.Error("should have auto-generated header when autoGenerated=true")
	}

	// Verify the actual content follows the header.
	if !strings.Contains(content, "FR-001") {
		t.Error("content after header should contain FR-001")
	}
}

// --- RenderAndWriteBusinessRules ---

func TestRenderAndWriteBusinessRules_Success(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.BusinessRulesData{
		Name:        "test-project",
		Definitions: "- **Customer**: A person who has purchased",
		Facts:       "- A Customer has exactly one Account",
		Constraints: "- When an Order exceeds $500, Then manager approval is required",
	}

	content, err := RenderAndWriteBusinessRules(tmpDir, renderer, data, false)
	if err != nil {
		t.Fatalf("RenderAndWriteBusinessRules: %v", err)
	}

	if !strings.Contains(content, "Customer") {
		t.Error("returned content should contain domain terms")
	}

	// Verify file was created.
	path := config.StagePath(tmpDir, config.StageBusinessRules)
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Error("business-rules.md should be created")
	}

	// No header when autoGenerated=false.
	if strings.Contains(content, autoGeneratedHeader) {
		t.Error("should NOT have auto-generated header")
	}
}

func TestRenderAndWriteBusinessRules_AutoGenerated(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.BusinessRulesData{
		Name:        "test-project",
		Definitions: "- **User**: A registered person",
		Facts:       "- A User has one Profile",
		Constraints: "- When a User is banned, Then they cannot log in",
	}

	content, err := RenderAndWriteBusinessRules(tmpDir, renderer, data, true)
	if err != nil {
		t.Fatalf("RenderAndWriteBusinessRules: %v", err)
	}

	if !strings.HasPrefix(content, autoGeneratedHeader) {
		t.Error("should have auto-generated header when autoGenerated=true")
	}
}

// --- RenderAndWriteDesign ---

func TestRenderAndWriteDesign_Success(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.DesignData{
		Name:                 "test-project",
		ArchitectureOverview: "A modular monolith using Clean Architecture",
		TechStack:            "- **Runtime**: Go 1.25",
		Components:           "### AuthModule\n- Handles user auth",
		DataModel:            "### User\n| id | UUID |",
	}

	content, err := RenderAndWriteDesign(tmpDir, renderer, data, false)
	if err != nil {
		t.Fatalf("RenderAndWriteDesign: %v", err)
	}

	if !strings.Contains(content, "Clean Architecture") {
		t.Error("returned content should contain architecture overview")
	}
	if !strings.Contains(content, "AuthModule") {
		t.Error("returned content should contain component")
	}

	// Verify file was created.
	path := config.StagePath(tmpDir, config.StageDesign)
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Error("design.md should be created")
	}

	// No header.
	if strings.Contains(content, autoGeneratedHeader) {
		t.Error("should NOT have auto-generated header")
	}
}

func TestRenderAndWriteDesign_AutoGenerated(t *testing.T) {
	tmpDir := t.TempDir()

	renderer, err := templates.NewRenderer()
	if err != nil {
		t.Fatalf("NewRenderer: %v", err)
	}

	data := templates.DesignData{
		Name:                 "test-project",
		ArchitectureOverview: "Microservices",
		TechStack:            "Node.js",
		Components:           "API Gateway",
		DataModel:            "Users table",
	}

	content, err := RenderAndWriteDesign(tmpDir, renderer, data, true)
	if err != nil {
		t.Fatalf("RenderAndWriteDesign: %v", err)
	}

	if !strings.HasPrefix(content, autoGeneratedHeader) {
		t.Error("should have auto-generated header when autoGenerated=true")
	}
}

// --- ArtifactExists ---

func TestArtifactExists_Exists(t *testing.T) {
	tmpDir := t.TempDir()

	// Create sdd/ directory and a requirements file.
	sddDir := filepath.Join(tmpDir, "sdd")
	if err := os.MkdirAll(sddDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}
	path := config.StagePath(tmpDir, config.StageSpecify)
	if err := os.WriteFile(path, []byte("# Requirements\n\n- FR-001"), 0o644); err != nil {
		t.Fatalf("write: %v", err)
	}

	if !ArtifactExists(tmpDir, config.StageSpecify) {
		t.Error("ArtifactExists should return true for existing file")
	}
}

func TestArtifactExists_NotExists(t *testing.T) {
	tmpDir := t.TempDir()

	if ArtifactExists(tmpDir, config.StageSpecify) {
		t.Error("ArtifactExists should return false for missing file")
	}
}

func TestArtifactExists_EmptyFile(t *testing.T) {
	tmpDir := t.TempDir()

	sddDir := filepath.Join(tmpDir, "sdd")
	if err := os.MkdirAll(sddDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}
	path := config.StagePath(tmpDir, config.StageSpecify)
	if err := os.WriteFile(path, []byte(""), 0o644); err != nil {
		t.Fatalf("write: %v", err)
	}

	if ArtifactExists(tmpDir, config.StageSpecify) {
		t.Error("ArtifactExists should return false for empty file")
	}
}

func TestArtifactExists_UnknownStage(t *testing.T) {
	tmpDir := t.TempDir()

	if ArtifactExists(tmpDir, config.Stage("nonexistent")) {
		t.Error("ArtifactExists should return false for unknown stage")
	}
}

// --- CheckSDDArtifacts ---

func TestCheckSDDArtifacts_NoneExist(t *testing.T) {
	tmpDir := t.TempDir()

	if CheckSDDArtifacts(tmpDir) {
		t.Error("CheckSDDArtifacts should return false when no artifacts exist")
	}
}

func TestCheckSDDArtifacts_OneExists(t *testing.T) {
	tmpDir := t.TempDir()

	sddDir := filepath.Join(tmpDir, "sdd")
	if err := os.MkdirAll(sddDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}

	// Create only design.md.
	path := config.StagePath(tmpDir, config.StageDesign)
	if err := os.WriteFile(path, []byte("# Design\n\nSome content"), 0o644); err != nil {
		t.Fatalf("write: %v", err)
	}

	if !CheckSDDArtifacts(tmpDir) {
		t.Error("CheckSDDArtifacts should return true when at least one artifact exists")
	}
}

func TestCheckSDDArtifacts_AllExist(t *testing.T) {
	tmpDir := t.TempDir()

	sddDir := filepath.Join(tmpDir, "sdd")
	if err := os.MkdirAll(sddDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}

	stages := []config.Stage{config.StageBusinessRules, config.StageSpecify, config.StageDesign}
	for _, stage := range stages {
		path := config.StagePath(tmpDir, stage)
		if err := os.WriteFile(path, []byte("# Content\n"), 0o644); err != nil {
			t.Fatalf("write %s: %v", stage, err)
		}
	}

	if !CheckSDDArtifacts(tmpDir) {
		t.Error("CheckSDDArtifacts should return true when all artifacts exist")
	}
}
