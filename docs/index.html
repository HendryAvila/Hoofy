<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hoofy - Learn AI Development the Smart Way</title>
<meta name="description" content="Interactive documentation for Hoofy ‚Äî the MCP server that gives AI agents memory, discipline, and spec-driven development.">
<style>
/* ============================================
   CSS CUSTOM PROPERTIES
   ============================================ */
:root {
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --bg-card: #1c2129;
  --accent-blue: #58a6ff;
  --accent-purple: #bc8cff;
  --accent-green: #3fb950;
  --accent-gold: #d29922;
  --accent-red: #f85149;
  --text-primary: #f0f6fc;
  --text-secondary: #8b949e;
  --text-muted: #484f58;
  --border: #30363d;
  --glow-blue: 0 0 20px rgba(88, 166, 255, 0.3);
  --glow-purple: 0 0 20px rgba(188, 140, 255, 0.3);
  --glow-green: 0 0 20px rgba(63, 185, 80, 0.4);
  --glow-gold: 0 0 20px rgba(210, 153, 34, 0.4);
  --node-size: 72px;
  --path-width: 4px;
}

/* ============================================
   RESET & BASE
   ============================================ */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
  overflow-x: hidden;
}

/* ============================================
   AMBIENT PARTICLE CANVAS
   ============================================ */
#ambient-canvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 0;
}

/* ============================================
   HERO SECTION
   ============================================ */
.hero {
  text-align: center;
  padding: 80px 20px 48px;
  position: relative;
  overflow: hidden;
  z-index: 1;
}

/* Animated aurora background */
.hero::before {
  content: '';
  position: absolute;
  top: -60%;
  left: -30%;
  width: 160%;
  height: 220%;
  background:
    radial-gradient(ellipse at 20% 50%, rgba(88,166,255,0.12) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 50%, rgba(188,140,255,0.10) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 80%, rgba(63,185,80,0.06) 0%, transparent 40%);
  animation: auroraShift 12s ease-in-out infinite alternate;
  pointer-events: none;
}

.hero::after {
  content: '';
  position: absolute;
  top: -40%;
  left: -20%;
  width: 140%;
  height: 200%;
  background:
    radial-gradient(ellipse at 70% 30%, rgba(210,153,34,0.07) 0%, transparent 45%),
    radial-gradient(ellipse at 30% 70%, rgba(88,166,255,0.06) 0%, transparent 45%);
  animation: auroraShift 15s ease-in-out 3s infinite alternate-reverse;
  pointer-events: none;
}

@keyframes auroraShift {
  0% { transform: translate(0, 0) scale(1); opacity: 0.7; }
  33% { transform: translate(3%, -2%) scale(1.03); opacity: 1; }
  66% { transform: translate(-2%, 3%) scale(0.97); opacity: 0.8; }
  100% { transform: translate(1%, -1%) scale(1.01); opacity: 0.9; }
}

.hero-icon {
  font-size: 72px;
  display: block;
  margin-bottom: 20px;
  animation: heroFloat 4s ease-in-out infinite;
  position: relative;
  filter: drop-shadow(0 0 20px rgba(88,166,255,0.3));
}

@keyframes heroFloat {
  0%, 100% { transform: translateY(0) rotate(-2deg); }
  25% { transform: translateY(-8px) rotate(0deg); }
  50% { transform: translateY(-14px) rotate(2deg); }
  75% { transform: translateY(-6px) rotate(0deg); }
}

.hero h1 {
  font-size: 3rem;
  font-weight: 800;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple), var(--accent-blue));
  background-size: 200% 100%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 12px;
  position: relative;
  animation: gradientFlow 4s ease infinite;
}

@keyframes gradientFlow {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

.hero .tagline {
  font-size: 1.2rem;
  color: var(--text-secondary);
  max-width: 550px;
  margin: 0 auto 32px;
  position: relative;
}

/* Ambient floating symbols in hero */
.hero-ambient {
  position: absolute;
  inset: 0;
  overflow: hidden;
  pointer-events: none;
  z-index: 0;
}

.hero-ambient .float-symbol {
  position: absolute;
  font-size: 1.2rem;
  opacity: 0;
  animation: floatUp linear infinite;
}

@keyframes floatUp {
  0% { transform: translateY(100%) scale(0.5); opacity: 0; }
  10% { opacity: 0.15; }
  90% { opacity: 0.15; }
  100% { transform: translateY(-200%) scale(1); opacity: 0; }
}

/* ============================================
   PROGRESS BAR
   ============================================ */
.progress-container {
  max-width: 400px;
  margin: 0 auto;
  position: relative;
}

.progress-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.progress-count {
  font-weight: 700;
  color: var(--accent-blue);
  font-size: 0.95rem;
}

.progress-bar {
  width: 100%;
  height: 10px;
  background: var(--bg-tertiary);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
  border-radius: 10px;
  transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  width: 0%;
}

.progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* ============================================
   SKILL TREE
   ============================================ */
.skill-tree {
  max-width: 600px;
  margin: 0 auto;
  padding: 40px 20px 80px;
  position: relative;
  z-index: 1;
}

/* Track labels */
.track-label {
  text-align: center;
  margin: 48px 0 32px;
  position: relative;
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.6s ease, transform 0.6s ease;
}

.track-label.revealed {
  opacity: 1;
  transform: translateY(0);
}

.track-label:first-child {
  margin-top: 16px;
}

.track-label span {
  display: inline-block;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  padding: 8px 24px;
  border-radius: 20px;
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text-secondary);
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

/* Node row */
.node-row {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  margin: 12px 0;
  padding: 8px 0;
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 0.5s ease, transform 0.5s ease;
}

.node-row.revealed {
  opacity: 1;
  transform: translateY(0);
}

.node-row.left { justify-content: flex-start; padding-left: 20%; }
.node-row.right { justify-content: flex-end; padding-right: 20%; }
.node-row.center { justify-content: center; }

/* SVG Connector overlay */
.connector-svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.connector-svg path {
  fill: none;
  stroke: var(--border);
  stroke-width: var(--path-width);
  stroke-linecap: round;
  transition: stroke 0.4s ease, filter 0.4s ease;
}

.connector-svg path.connector-active {
  stroke: var(--accent-blue);
  filter: drop-shadow(0 0 4px rgba(88,166,255,0.3));
  animation: connectorPulse 3s ease-in-out infinite;
}

.connector-svg path.connector-completed {
  stroke: var(--accent-green);
  filter: drop-shadow(0 0 3px rgba(63,185,80,0.25));
}

@keyframes connectorPulse {
  0%, 100% { filter: drop-shadow(0 0 4px rgba(88,166,255,0.3)); }
  50% { filter: drop-shadow(0 0 8px rgba(88,166,255,0.5)); }
}

/* ============================================
   NODES
   ============================================ */
.node {
  width: var(--node-size);
  height: var(--node-size);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.8rem;
  cursor: default;
  position: relative;
  z-index: 2;
  transition: all 0.3s ease, transform 0.15s ease;
  border: 3px solid var(--border);
  background: var(--bg-secondary);
  user-select: none;
  -webkit-user-select: none;
  will-change: transform;
}

/* Locked */
.node.locked {
  opacity: 0.4;
  filter: grayscale(80%);
  cursor: not-allowed;
}

.node.locked .node-icon {
  filter: grayscale(100%) brightness(0.5);
}

.node.locked::after {
  content: 'üîí';
  position: absolute;
  font-size: 0.7rem;
  bottom: -2px;
  right: -2px;
}

/* Unlocked / Current */
.node.current {
  border-color: var(--accent-blue);
  box-shadow: var(--glow-blue), inset 0 0 20px rgba(88,166,255,0.05);
  cursor: pointer;
  animation: nodePulse 2.5s ease-in-out infinite;
}

.node.current::before {
  content: '';
  position: absolute;
  inset: -6px;
  border-radius: 50%;
  border: 2px solid rgba(88,166,255,0.15);
  animation: nodeRing 2.5s ease-in-out infinite;
}

.node.current:hover {
  transform: scale(1.15);
  box-shadow: 0 0 40px rgba(88, 166, 255, 0.5), 0 0 80px rgba(88,166,255,0.15);
}

@keyframes nodePulse {
  0%, 100% { transform: scale(1); box-shadow: var(--glow-blue); }
  50% { transform: scale(1.06); box-shadow: 0 0 35px rgba(88, 166, 255, 0.5); }
}

@keyframes nodeRing {
  0%, 100% { transform: scale(1); opacity: 0.5; }
  50% { transform: scale(1.2); opacity: 0; }
}

/* Completed */
.node.completed {
  border-color: var(--accent-green);
  box-shadow: var(--glow-green);
  cursor: pointer;
  animation: none;
  background: linear-gradient(135deg, rgba(63,185,80,0.15), var(--bg-secondary));
}

.node.completed::before {
  content: none;
}

.node.completed:hover {
  transform: scale(1.1);
  box-shadow: 0 0 30px rgba(63,185,80,0.4);
}

.node.completed::after {
  content: '‚úì';
  position: absolute;
  bottom: -4px;
  right: -4px;
  width: 22px;
  height: 22px;
  background: var(--accent-green);
  color: #fff;
  border-radius: 50%;
  font-size: 0.7rem;
  font-weight: 800;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid var(--bg-primary);
}

/* Unlock animation */
.node.unlock-anim {
  animation: nodeUnlock 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

@keyframes nodeUnlock {
  0% { transform: scale(0.5); opacity: 0.3; }
  60% { transform: scale(1.15); }
  100% { transform: scale(1); opacity: 1; }
}

/* Node title tooltip */
.node-title {
  position: absolute;
  bottom: calc(100% + 10px);
  left: 50%;
  transform: translateX(-50%);
  white-space: nowrap;
  font-size: 0.75rem;
  color: var(--text-secondary);
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
  background: var(--bg-secondary);
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid var(--border);
}

.node:not(.locked):hover .node-title {
  opacity: 1;
}

.node-icon {
  font-size: 1.6rem;
  line-height: 1;
}

/* ============================================
   MODAL
   ============================================ */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 100;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 20px;
  opacity: 0;
  transition: opacity 0.25s ease;
}

.modal-backdrop.active {
  display: flex;
  opacity: 1;
}

.modal-backdrop.closing {
  opacity: 0;
}

.modal {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  max-width: 520px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  position: relative;
  transform: translateY(30px) scale(0.95);
  transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s;
  opacity: 0;
}

.modal-backdrop.active .modal {
  transform: translateY(0) scale(1);
  opacity: 1;
}

.modal-backdrop.closing .modal {
  transform: translateY(20px) scale(0.95);
  opacity: 0;
}

.modal-close {
  position: absolute;
  top: 16px;
  right: 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 32px;
  height: 32px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.2s;
  z-index: 2;
}

.modal-close:hover {
  background: var(--accent-red);
  color: white;
  border-color: var(--accent-red);
}

.modal-header {
  padding: 32px 32px 0;
  text-align: center;
}

.modal-icon {
  font-size: 3rem;
  display: block;
  margin-bottom: 12px;
}

.modal-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 4px;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.modal-track {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 16px;
}

.modal-body {
  padding: 20px 32px;
}

.modal-summary {
  font-size: 1.05rem;
  color: var(--text-secondary);
  line-height: 1.7;
  margin-bottom: 20px;
}

/* Learn More expandable */
.learn-more-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: 1px solid var(--border);
  color: var(--accent-blue);
  padding: 10px 20px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 600;
  width: 100%;
  transition: all 0.2s;
  font-family: inherit;
}

.learn-more-toggle:hover {
  background: rgba(88, 166, 255, 0.08);
  border-color: var(--accent-blue);
}

.learn-more-toggle .arrow {
  transition: transform 0.3s;
  font-size: 0.7rem;
}

.learn-more-toggle.expanded .arrow {
  transform: rotate(180deg);
}

.learn-more-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), padding 0.3s;
  padding: 0 0;
}

.learn-more-content.expanded {
  max-height: 1200px;
  padding: 20px 0 0;
}

.learn-more-section {
  margin-bottom: 20px;
}

.learn-more-section h4 {
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--accent-purple);
  margin-bottom: 8px;
  font-weight: 700;
}

.learn-more-section p,
.learn-more-section ul {
  font-size: 0.92rem;
  color: var(--text-secondary);
  line-height: 1.7;
}

.learn-more-section ul {
  padding-left: 20px;
}

.learn-more-section li {
  margin-bottom: 6px;
}

.learn-more-section code {
  background: var(--bg-tertiary);
  padding: 2px 7px;
  border-radius: 4px;
  font-size: 0.85rem;
  color: var(--accent-blue);
  font-family: 'SF Mono', 'Fira Code', monospace;
}

.learn-more-section pre {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 14px 16px;
  overflow-x: auto;
  margin: 10px 0;
  font-size: 0.82rem;
  line-height: 1.5;
}

.learn-more-section pre code {
  background: none;
  padding: 0;
  color: var(--text-secondary);
}

/* Modal footer */
.modal-footer {
  padding: 16px 32px 28px;
  text-align: center;
}

.btn-complete {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
  color: white;
  border: none;
  padding: 14px 40px;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  font-family: inherit;
  letter-spacing: 0.3px;
}

.btn-complete:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(88, 166, 255, 0.3);
}

.btn-complete:active {
  transform: translateY(0);
}

.btn-complete.completed-btn {
  background: var(--bg-tertiary);
  color: var(--accent-green);
  cursor: default;
  border: 1px solid var(--accent-green);
}

.btn-complete.completed-btn:hover {
  transform: none;
  box-shadow: none;
}

/* ============================================
   MASCOT
   ============================================ */
.mascot {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 16px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
  z-index: 90;
  transform: translateX(150%);
  transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  box-shadow: 0 10px 40px rgba(0,0,0,0.3), 0 0 20px rgba(88,166,255,0.05);
  max-width: 320px;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.mascot.visible {
  transform: translateX(0);
}

.mascot-emoji {
  font-size: 2rem;
  flex-shrink: 0;
  animation: mascotBob 2s ease-in-out infinite;
}

@keyframes mascotBob {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-3px) rotate(-3deg); }
  75% { transform: translateY(2px) rotate(2deg); }
}

.mascot-msg {
  font-size: 0.9rem;
  color: var(--text-secondary);
  line-height: 1.4;
}

.mascot-msg strong {
  color: var(--accent-gold);
}

/* ============================================
   CONFETTI CANVAS
   ============================================ */
#confetti-canvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 200;
}

/* ============================================
   COMPLETION BANNER
   ============================================ */
.completion-banner {
  text-align: center;
  padding: 40px 20px;
  display: none;
}

.completion-banner.visible {
  display: block;
  animation: slideUp 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.completion-banner h2 {
  font-size: 2rem;
  margin-bottom: 8px;
  background: linear-gradient(135deg, var(--accent-gold), var(--accent-green));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.completion-banner p {
  color: var(--text-secondary);
  font-size: 1.1rem;
}

@keyframes slideUp {
  from { opacity: 0; transform: translateY(30px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ============================================
   SPARKLE EFFECT
   ============================================ */
.sparkle-container {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 10;
}

.sparkle {
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  animation: sparkleFade 0.8s ease-out forwards;
}

@keyframes sparkleFade {
  0% { transform: scale(0) translate(0, 0); opacity: 1; }
  50% { transform: scale(1.5) translate(var(--tx), var(--ty)); opacity: 0.8; }
  100% { transform: scale(0) translate(calc(var(--tx) * 2), calc(var(--ty) * 2)); opacity: 0; }
}

/* ============================================
   FOOTER
   ============================================ */
.site-footer {
  text-align: center;
  padding: 40px 20px;
  border-top: 1px solid var(--border);
  margin-top: 40px;
  position: relative;
  z-index: 1;
}

.site-footer p {
  color: var(--text-muted);
  font-size: 0.85rem;
}

.site-footer a {
  color: var(--accent-blue);
  text-decoration: none;
}

.site-footer a:hover {
  text-decoration: underline;
}

.btn-reset {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.8rem;
  margin-top: 12px;
  transition: all 0.2s;
  font-family: inherit;
}

.btn-reset:hover {
  border-color: var(--accent-red);
  color: var(--accent-red);
}

/* ============================================
   RESPONSIVE
   ============================================ */
@media (max-width: 768px) {
  .hero h1 { font-size: 2rem; }
  .hero .tagline { font-size: 1rem; }
  .hero { padding: 40px 16px 24px; }

  .skill-tree { padding: 24px 16px 60px; }

  .node-row.left,
  .node-row.right { 
    justify-content: center; 
    padding-left: 0;
    padding-right: 0;
  }

  :root { --node-size: 64px; }

  .modal { max-width: 95%; }
  .modal-header { padding: 24px 20px 0; }
  .modal-body { padding: 16px 20px; }
  .modal-footer { padding: 12px 20px 24px; }

  .mascot { 
    bottom: 16px; 
    right: 16px; 
    left: 16px;
    max-width: none;
  }

  .node-title { display: none; }

  /* Reduce particles on mobile for performance */
  #ambient-canvas { opacity: 0.5; }
}

/* Respect reduced motion preference */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
  #ambient-canvas { display: none; }
  .hero-ambient { display: none; }
}

/* ============================================
   SCROLLBAR
   ============================================ */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
.modal::-webkit-scrollbar { width: 6px; }
</style>
</head>
<body>

<!-- Ambient particle background -->
<canvas id="ambient-canvas"></canvas>

<!-- ============================================
     HERO
     ============================================ -->
<header class="hero">
  <div class="hero-ambient" id="hero-ambient"></div>
  <span class="hero-icon">üê¥</span>
  <h1>Hoofy</h1>
  <p class="tagline">Memory, discipline, and spec-driven development for AI agents. Learn what makes Hoofy tick ‚Äî one concept at a time.</p>
  <div class="progress-container">
    <div class="progress-label">
      <span>Your progress</span>
      <span class="progress-count" id="progress-count">0 / 14</span>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
  </div>
</header>

<!-- ============================================
     SKILL TREE (generated by JS)
     ============================================ -->
<main class="skill-tree" id="skill-tree"></main>

<!-- ============================================
     COMPLETION BANNER
     ============================================ -->
<div class="completion-banner" id="completion-banner">
  <h2>üèÜ You mastered Hoofy!</h2>
  <p>You now know every feature. Go build something amazing ‚Äî with specs first, obviously. üê¥</p>
</div>

<!-- ============================================
     FOOTER
     ============================================ -->
<footer class="site-footer">
  <p>Built with üê¥ by <a href="https://github.com/HendryAvila/Hoofy" target="_blank" rel="noopener">Hoofy</a> ‚Äî every feature grounded in research.</p>
  <button type="button" class="btn-reset" id="btn-reset">Reset Progress</button>
</footer>

<!-- ============================================
     MODAL
     ============================================ -->
<div class="modal-backdrop" id="modal-backdrop">
  <div class="modal" id="modal" role="dialog" aria-modal="true">
    <button type="button" class="modal-close" id="modal-close" aria-label="Close">‚úï</button>
    <div class="modal-header">
      <span class="modal-icon" id="modal-icon"></span>
      <h2 class="modal-title" id="modal-title"></h2>
      <div class="modal-track" id="modal-track"></div>
    </div>
    <div class="modal-body">
      <p class="modal-summary" id="modal-summary"></p>
      <button type="button" class="learn-more-toggle" id="learn-more-toggle">
        <span class="arrow">‚ñº</span> Learn More
      </button>
      <div class="learn-more-content" id="learn-more-content"></div>
    </div>
    <div class="modal-footer">
      <button type="button" class="btn-complete" id="btn-complete">Got it! ‚úì</button>
    </div>
  </div>
</div>

<!-- ============================================
     MASCOT
     ============================================ -->
<div class="mascot" id="mascot">
  <span class="mascot-emoji">üê¥</span>
  <span class="mascot-msg" id="mascot-msg"></span>
</div>

<!-- ============================================
     CONFETTI CANVAS
     ============================================ -->
<canvas id="confetti-canvas"></canvas>

<script>
/* ============================================
   NODE DATA ‚Äî 14 concepts
   ============================================ */
const NODES = [
  /* ‚îÄ‚îÄ‚îÄ Track 1: Foundation ‚îÄ‚îÄ‚îÄ */
  {
    id: 1,
    track: 'foundation',
    trackLabel: 'üß† Foundation',
    trackStart: true,
    icon: 'üê¥',
    title: 'What is Hoofy?',
    summary: 'Hoofy is an MCP server that gives AI agents two things they desperately lack: persistent memory and structured discipline. It prevents hallucinations by forcing specs before code and remembers context across sessions.',
    details: {
      what: `<p>Hoofy is a <strong>single static binary</strong> (written in Go) that speaks the MCP (Model Context Protocol). It plugs into AI assistants like Claude, giving them 34 tools across three systems: Memory, Project Pipeline, and Change Pipeline.</p>
<p>Think of it as the difference between an AI with amnesia that starts fresh every conversation, and an AI that remembers your architecture decisions, knows your codebase conventions, and refuses to write code without understanding the requirements first.</p>`,
      how: `<pre><code># Install and run ‚Äî zero dependencies
hoofy serve

# The AI uses 34 MCP tools automatically:
mem_save, mem_search, mem_context,
sdd_change, sdd_init_project, sdd_clarify...</code></pre>`,
      why: '<p>Research from <strong>METR 2025</strong> found that experienced developers were 19% <em>slower</em> with unstructured AI despite feeling 20% faster. Hoofy provides the structure that makes AI actually help.</p>'
    }
  },
  {
    id: 2,
    track: 'foundation',
    icon: 'üíæ',
    title: 'Persistent Memory',
    summary: 'SQLite database with FTS5 full-text search. The AI saves observations (decisions, bugs, patterns, discoveries) and retrieves them across sessions. No more repeating yourself.',
    details: {
      what: `<p>Every important insight gets saved as an <strong>observation</strong> with a title, type, content, and project tag. Observations are stored in SQLite with FTS5 full-text search indexing, so the AI can find past decisions instantly.</p>
<p>Sessions track work periods ‚Äî when you start, what you accomplished, and a structured summary for future sessions to read.</p>`,
      how: `<pre><code># The AI saves observations proactively:
mem_save(title="JWT auth middleware", 
         type="decision",
         content="**What**: Switched to JWT...")

# And retrieves them later:
mem_search(query="authentication")
mem_context(limit=20)  # recent observations</code></pre>`,
      why: '<p>Anthropic\'s <strong>"Effective Context Engineering"</strong> article defines this as "structured note-taking / agentic memory" ‚Äî the agent writes notes persisted outside the context window and pulls them back later.</p>'
    }
  },
  {
    id: 3,
    track: 'foundation',
    icon: 'üï∏Ô∏è',
    title: 'Knowledge Graph',
    summary: 'Observations aren\'t flat notes ‚Äî they\'re connected with typed relations (caused_by, implements, depends_on, supersedes). Navigate your decision history like a web, not a list.',
    details: {
      what: `<p>Relations are typed, directional edges between observations. When you fix a bug, you can relate it to the decision that caused it. When you implement a feature, link the tasks to their requirements. When a new decision replaces an old one, mark it as <code>supersedes</code>.</p>
<p><code>mem_build_context</code> traverses the graph from any starting point, showing connected observations up to a configurable depth. It transforms flat memories into a navigable web.</p>`,
      how: `<pre><code># Create a relation:
mem_relate(from_id=42, to_id=37, 
           relation_type="caused_by",
           note="This bug was caused by the 
                 auth decision in observation 37")

# Traverse the graph:
mem_build_context(observation_id=42, depth=3)</code></pre>`,
      why: '<p>Isolated observations lose context over time. Relations preserve the <strong>why</strong> ‚Äî not just what was decided, but what led to it and what it affected. This is how experienced developers think: in connected webs, not isolated facts.</p>'
    }
  },

  /* ‚îÄ‚îÄ‚îÄ Track 2: SDD Pipeline ‚îÄ‚îÄ‚îÄ */
  {
    id: 4,
    track: 'sdd-pipeline',
    trackLabel: 'üìã Spec-Driven Development',
    trackStart: true,
    icon: 'üìã',
    title: 'The SDD Pipeline',
    summary: 'Eight stages from vague idea to validated architecture: propose ‚Üí specify ‚Üí business rules ‚Üí clarify ‚Üí design ‚Üí tasks ‚Üí validate. No skipping allowed. The AI generates content, the pipeline enforces order.',
    details: {
      what: `<p>The SDD (Spec-Driven Development) pipeline is an <strong>8-stage sequential workflow</strong> for greenfield projects. Each stage produces a markdown artifact, and you can't advance to the next stage until the current one is complete.</p>
<p>The pipeline stages are: <strong>init ‚Üí propose ‚Üí specify ‚Üí business-rules ‚Üí clarify ‚Üí design ‚Üí tasks ‚Üí validate</strong>. Tools are "dumb storage" ‚Äî the AI generates the content, the tools save it and advance the state machine.</p>`,
      how: `<pre><code># 1. Initialize the project
sdd_init_project(name="MyApp", 
                 description="A task manager")

# 2. Create proposal (problem, users, solution)
sdd_create_proposal(problem_statement="...",
                    target_users="...", ...)

# 3. Generate requirements (MoSCoW)
sdd_generate_requirements(must_have="...",
                          should_have="...", ...)

# ... continues through all stages</code></pre>`,
      why: '<p><strong>IEEE 720574</strong> shows that fixing a requirement error in production costs 10-100x more than catching it during the requirements phase. The pipeline front-loads thinking where it\'s cheapest.</p>'
    }
  },
  {
    id: 5,
    track: 'sdd-pipeline',
    icon: 'üö™',
    title: 'The Clarity Gate',
    summary: 'The core innovation. Analyzes requirements across 8 dimensions of ambiguity and BLOCKS advancement until clarity exceeds the threshold. No more "just figure it out as you go."',
    details: {
      what: `<p>The Clarity Gate sits between requirements and design. It scores your specifications across <strong>8 dimensions</strong>: target users, core functionality, data model, integrations, edge cases, security, scale/performance, and scope boundaries.</p>
<p>Each dimension gets a score (0-100). The weighted average must exceed the threshold ‚Äî <strong>70 for guided mode, 50 for expert mode</strong> ‚Äî or the pipeline won't advance. The AI generates specific questions to resolve ambiguities.</p>`,
      how: `<pre><code># First call ‚Äî analyze requirements:
sdd_clarify()
# Returns: dimensions, scoring framework

# AI generates questions, user answers
# Second call ‚Äî submit scores:
sdd_clarify(
  answers="Q1: ... A1: ...",
  dimension_scores="target_users:85,
    core_functionality:90,data_model:70,
    integrations:60,edge_cases:55,
    security:75,scale_performance:65,
    scope_boundaries:80"
)</code></pre>`,
      why: '<p>This is Hoofy\'s <strong>evaluator-optimizer pattern</strong> from Anthropic\'s "Building Effective Agents". It forces iterative refinement of requirements until they\'re clear enough to build from. Most AI-generated code fails because the requirements were ambiguous, not because the AI can\'t code.</p>'
    }
  },
  {
    id: 6,
    track: 'sdd-pipeline',
    icon: 'üìú',
    title: 'Business Rules',
    summary: 'Declarative rules extracted from requirements using BRG taxonomy (Definitions, Facts, Constraints, Derivations) and DDD Ubiquitous Language. Rules are first-class citizens, not buried in code.',
    details: {
      what: `<p>Business rules are structural truths about your domain. They sit between requirements and the Clarity Gate. The AI extracts four types of rules:</p>
<ul>
<li><strong>Definitions</strong> ‚Äî Domain terms with precise meaning (Ubiquitous Language)</li>
<li><strong>Facts</strong> ‚Äî Relationships that are always true ("A Customer has exactly one Account")</li>
<li><strong>Constraints</strong> ‚Äî Behavioral boundaries ("When order > $500, then approval required")</li>
<li><strong>Derivations</strong> ‚Äî Computed knowledge ("Customer is premium when spend > $10K")</li>
</ul>`,
      how: `<pre><code>sdd_create_business_rules(
  definitions="**Customer**: A person who has 
    completed at least one purchase...",
  facts="A Customer has exactly one Account.
    An Account has zero or more Orders...",
  constraints="When Order total > $500, Then 
    manager approval is required...",
  derivations="Customer is 'premium' when total 
    spend exceeds $10,000 in 12 months..."
)</code></pre>`,
      why: '<p>The <strong>Business Rules Group Manifesto</strong> (Ronald Ross) establishes that rules should be declarative, separate from processes, and treated as first-class citizens. When rules live in code, they get lost. When they\'re explicit, they\'re verifiable.</p>'
    }
  },

  /* ‚îÄ‚îÄ‚îÄ Track 3: Adaptive Changes ‚îÄ‚îÄ‚îÄ */
  {
    id: 7,
    track: 'adaptive-changes',
    trackLabel: 'üîÑ Adaptive Changes',
    trackStart: true,
    icon: 'üîÑ',
    title: 'Change Pipeline',
    summary: '90% of real work is on existing code. Four change types (feature, fix, refactor, enhancement) times three sizes (small, medium, large) equals 12 adaptive workflows. Only the stages you need.',
    details: {
      what: `<p>The full 8-stage pipeline is for greenfield projects. For ongoing development, the <strong>adaptive change pipeline</strong> selects only the stages needed based on what you're doing and how complex it is.</p>
<p>A small bug fix gets 4 stages. A large new feature gets 7. Each change creates a directory with markdown artifacts, and only <strong>one active change</strong> is allowed at a time ‚Äî forcing you to finish what you started.</p>`,
      how: `<pre><code># Small fix: describe ‚Üí context-check ‚Üí tasks ‚Üí verify
sdd_change(type="fix", size="small",
  description="Fix FTS5 empty query crash")

# Large feature: propose ‚Üí context-check ‚Üí spec ‚Üí 
#   clarify ‚Üí design ‚Üí tasks ‚Üí verify  
sdd_change(type="feature", size="large",
  description="Add real-time collaboration")

# Work through stages:
sdd_change_advance(content="...")  # saves & advances
sdd_change_status()  # check progress</code></pre>`,
      why: '<p>Anthropic\'s "Building Effective Agents" recommends doing <strong>"the simplest thing that works"</strong> ‚Äî avoid over-engineering agent systems. A small fix doesn\'t need a full design document. A large feature does. The pipeline adapts to the work, not the other way around.</p>'
    }
  },
  {
    id: 8,
    track: 'adaptive-changes',
    icon: 'üîç',
    title: 'Context Check',
    summary: 'Mandatory first stage in every change flow. Scans existing specs, completed changes, memory, and convention files for conflicts. Even a small change can break a business rule ‚Äî this catches it.',
    details: {
      what: `<p>Context Check is a <strong>mandatory gate</strong> that runs before any work begins. It scans your project for:</p>
<ul>
<li>Existing SDD artifacts (requirements, business rules, design)</li>
<li>Previously completed changes (keyword-matched)</li>
<li>Memory observations (decisions, patterns)</li>
<li>Convention files (CLAUDE.md, AGENTS.md, CONTRIBUTING.md)</li>
</ul>
<p>The AI then analyzes the scan results using <strong>Requirements Smells heuristics</strong> (IEEE 29148) ‚Äî looking for subjective language, ambiguous adverbs, non-verifiable terms, and conflicts with existing rules.</p>`,
      how: `<pre><code># The tool scans ‚Äî the AI analyzes:
sdd_context_check(
  change_description="Add OAuth login",
  project_name="MyApp"
)
# Returns: structured report of findings
# AI checks for conflicts, ambiguity, impact

# Impact classification (SemVer model):
# - Breaking: existing tests would fail
# - Non-breaking: adds new behavior
# - Patch: internal change only</code></pre>`,
      why: '<p><strong>Femmer et al. 2017</strong> and <strong>IEEE 29148</strong> provide the heuristics for detecting requirements smells ‚Äî subjective language ("user-friendly"), totality terms ("always", "never"), and comparatives without baselines ("faster than"). Catching these early prevents expensive misunderstandings.</p>'
    }
  },
  {
    id: 9,
    track: 'adaptive-changes',
    icon: 'üèõÔ∏è',
    title: 'Architecture Decision Records',
    summary: 'Capture decisions with context, rationale, and rejected alternatives. Future you (or future AI sessions) will thank present you when they need to understand WHY something was built a certain way.',
    details: {
      what: `<p>ADRs (Architecture Decision Records) follow the <strong>Michael Nygard format</strong>: title, context, decision, rationale, and alternatives rejected. They can be captured at any time ‚Äî with or without an active change.</p>
<p>With an active change, ADRs are saved as files in the change directory AND to memory. Without an active change, they go to memory only. Either way, they're searchable and permanent.</p>`,
      how: `<pre><code>sdd_adr(
  title="Use PostgreSQL over MongoDB",
  context="Need to store relational data 
    with ACID transactions",
  decision="PostgreSQL 16",
  rationale="Data is inherently relational. 
    ACID compliance required for financial 
    records.",
  alternatives_rejected="MongoDB: no native 
    joins, eventual consistency. SQLite: 
    single-writer limitation."
)</code></pre>`,
      why: '<p>Code tells you WHAT was built. ADRs tell you <strong>WHY</strong>. Without them, every future developer (and AI agent) has to reverse-engineer the reasoning ‚Äî or worse, change something without understanding the original constraints.</p>'
    }
  },

  /* ‚îÄ‚îÄ‚îÄ Track 4: Context Engineering ‚îÄ‚îÄ‚îÄ */
  {
    id: 10,
    track: 'context-engineering',
    trackLabel: '‚ö° Context Engineering',
    trackStart: true,
    icon: 'üéöÔ∏è',
    title: 'Detail Level',
    summary: 'Five read-heavy tools support a detail_level parameter: summary (minimal tokens), standard (truncated snippets), or full (everything). Fetch the minimum you need first, then drill deeper.',
    details: {
      what: `<p>Not every tool call needs the full response. The <code>detail_level</code> parameter lets the AI choose how much data to receive:</p>
<ul>
<li><strong>summary</strong> ‚Äî IDs, titles, metadata only. For orientation and triage.</li>
<li><strong>standard</strong> ‚Äî Truncated content snippets. Good balance for most operations.</li>
<li><strong>full</strong> ‚Äî Complete untruncated content. Only when you need deep analysis.</li>
</ul>
<p><code>sdd_get_context</code> defaults to <strong>summary</strong> (most frequently called tool). Others default to <strong>standard</strong>.</p>`,
      how: `<pre><code># Quick scan ‚Äî what exists?
mem_search(query="auth", detail_level="summary")
# Returns: titles and IDs only (~50 tokens)

# Found something interesting ‚Äî get details:
mem_get_observation(id=42)
# Returns: full content for that one observation

# Progressive disclosure pattern:
# summary ‚Üí standard ‚Üí full ‚Üí get_observation</code></pre>`,
      why: '<p>Anthropic: <strong>"Context is a finite resource."</strong> Every token of context the AI reads costs attention. Sending 5000 tokens when 200 would suffice means the AI has less capacity for the actual task. Detail level is attention budgeting.</p>'
    }
  },
  {
    id: 11,
    track: 'context-engineering',
    icon: 'üìè',
    title: 'Budget Awareness',
    summary: 'Five tools accept a max_tokens parameter that hard-caps response size. Token estimation uses a fast len/4 heuristic. Every response shows its token footprint. Detail level controls WHAT, max_tokens controls HOW MUCH.',
    details: {
      what: `<p><code>max_tokens</code> is a hard cap on response size. The AI sets a budget, and the tool ensures the response stays within it. Token estimation uses <code>len(text)/4</code> ‚Äî a fast O(1) heuristic with no tokenizer dependency.</p>
<p>Every response from these tools includes a <code>üìè ~N tokens</code> footer showing estimated size. Budget-capped responses prepend a <code>‚ö° Budget-capped</code> notice so the AI knows data was truncated.</p>`,
      how: `<pre><code># "Give me context, but stay under 500 tokens"
mem_context(limit=20, max_tokens=500)

# Complementary with detail_level:
mem_search(query="auth", 
           detail_level="standard",
           max_tokens=1000)

# Every response shows its footprint:
# ... content ...
# üìè ~347 tokens</code></pre>`,
      why: '<p>Anthropic\'s multi-agent research found that <strong>"token usage explains 80% of performance variance"</strong> ‚Äî more tokens does NOT equal better results. Explicit budget caps prevent bloated responses that degrade AI performance.</p>'
    }
  },
  {
    id: 12,
    track: 'context-engineering',
    icon: 'üßπ',
    title: 'Navigation & Compaction',
    summary: 'Navigation hints tell the AI "üìä Showing 10 of 47" so it knows when data is incomplete. mem_compact cleans up stale observations. mem_progress tracks structured progress that survives context compaction.',
    details: {
      what: `<p>Three features working together to keep context fresh and navigable:</p>
<ul>
<li><strong>Navigation hints</strong> ‚Äî "üìä Showing X of Y" footer when results are capped by limit. The AI knows whether it's seeing everything or needs to adjust.</li>
<li><strong>mem_compact</strong> ‚Äî Identifies stale observations (older than N days) and batch soft-deletes them. Optionally creates a "compaction_summary" to preserve key knowledge.</li>
<li><strong>mem_progress</strong> ‚Äî Structured JSON progress docs that survive context compaction. One active progress per project, auto-upserted via topic key.</li>
</ul>`,
      how: `<pre><code># Navigation hints appear automatically:
mem_search(query="auth", limit=5)
# ... results ...
# üìä Showing 5 of 23 ‚Äî adjust limit for more

# Compact stale observations:
mem_compact(older_than_days=30)  # list candidates
mem_compact(compact_ids="12,15,18,22",
  summary="Auth decisions consolidated...")

# Track progress across context windows:
mem_progress(project="MyApp", 
  content='{"phase":"implementing","done":3}')</code></pre>`,
      why: '<p>Anthropic\'s "Effective Harnesses for Long-Running Agents" recommends that each session should <strong>"read progress, then start new work."</strong> <code>mem_progress</code> ensures handoff between sessions is smooth. Compaction prevents memory from growing unbounded.</p>'
    }
  },
  {
    id: 13,
    track: 'context-engineering',
    icon: 'üè∑Ô∏è',
    title: 'Sub-Agent Scoping',
    summary: 'When multiple AI sub-agents work in parallel, the namespace parameter isolates each agent\'s memory. Each sub-agent sees only its own notes. The orchestrator omits namespace to see everything.',
    details: {
      what: `<p>In multi-agent architectures (orchestrator + researcher + coder + reviewer), each sub-agent needs its own memory space. The <code>namespace</code> parameter tags observations with an isolation boundary.</p>
<p>Seven tools support namespace ‚Äî 4 write tools (<code>mem_save</code>, <code>mem_save_prompt</code>, <code>mem_session_summary</code>, <code>mem_progress</code>) and 3 read tools (<code>mem_search</code>, <code>mem_context</code>, <code>mem_compact</code>). The orchestrator omits namespace to see all observations across all sub-agents.</p>`,
      how: `<pre><code># Sub-agent saves with namespace:
mem_save(title="Auth API findings",
  namespace="subagent/researcher-123",
  content="...")

# Sub-agent reads only its own notes:
mem_search(query="auth", 
  namespace="subagent/researcher-123")

# Orchestrator sees EVERYTHING:
mem_search(query="auth")  # no namespace

# Convention:
# "subagent/task-123" ‚Äî by task
# "agent/researcher"  ‚Äî by role</code></pre>`,
      why: '<p>Anthropic\'s multi-agent research emphasizes that <strong>"each sub-agent works independently with its own context"</strong> ‚Äî parallel agents need memory isolation to prevent cross-contamination. Namespace provides opt-in isolation without separate databases.</p>'
    }
  },

  /* ‚îÄ‚îÄ‚îÄ Track 5: Boss Level ‚îÄ‚îÄ‚îÄ */
  {
    id: 14,
    track: 'boss-level',
    trackLabel: 'üèÜ Boss Level',
    trackStart: true,
    icon: 'üèÜ',
    title: 'Research Foundations',
    summary: 'Every Hoofy feature maps to published research ‚Äî 6 Anthropic engineering articles, IEEE standards, IREB, METR 2025, DORA 2025, Business Rules Group. This isn\'t vibes-driven development. It\'s evidence-based engineering.',
    details: {
      what: `<p>Hoofy doesn't add features because they "seem cool." Every capability maps to a specific recommendation from published research:</p>
<ul>
<li><strong>6 Anthropic articles</strong> ‚Äî Building Effective Agents, Effective Context Engineering, Writing Tools for Agents, Multi-Agent Research, Effective Harnesses, Claude Code Best Practices</li>
<li><strong>IEEE 29148 & IEEE 720574</strong> ‚Äî Requirements engineering standards</li>
<li><strong>METR 2025</strong> ‚Äî Experienced devs 19% slower with unstructured AI</li>
<li><strong>DORA 2025</strong> ‚Äî 7.2% delivery instability per 25% AI adoption without foundations</li>
<li><strong>Business Rules Group</strong> ‚Äî Declarative rules as first-class citizens</li>
<li><strong>EARS</strong> ‚Äî Easy Approach to Requirements Syntax</li>
</ul>`,
      how: `<pre><code># The full research mapping lives in:
# docs/research-foundations.md

# Example mapping:
# Anthropic: "Context is a finite resource"
#   ‚Üí detail_level parameter
#   ‚Üí max_tokens budget capping
#   ‚Üí mem_compact for stale cleanup

# IEEE 720574: "10-100x cost multiplier 
#   for requirement errors in production"
#   ‚Üí Clarity Gate catches ambiguities early</code></pre>`,
      why: '<p>Because <strong>"it works on my machine"</strong> is not a research methodology. Every feature should justify its existence with evidence. If you can\'t point to WHY a feature exists, it probably shouldn\'t. Hoofy practices what it preaches ‚Äî structured, justified, traceable.</p>'
    }
  }
];

/* ============================================
   STATE
   ============================================ */
const STORAGE_KEY = 'hoofy-docs-progress';
let completedIds = [];
let currentModalId = null;
let mascotTimer = null;
let mouseX = 0, mouseY = 0;

/* ============================================
   INIT
   ============================================ */
function init() {
  loadProgress();
  renderTree();
  renderProgress();
  bindEvents();
  checkMilestone(true);
  initAmbientParticles();
  initScrollReveal();
  initMouseParallax();
  initHeroAmbient();
}

function loadProgress() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    completedIds = saved ? JSON.parse(saved) : [];
    if (!Array.isArray(completedIds)) completedIds = [];
  } catch { completedIds = []; }
}

function saveProgress() {
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(completedIds)); } catch {}
}

/* ============================================
   NODE STATE
   ============================================ */
function getNodeState(id) {
  if (completedIds.includes(id)) return 'completed';
  // Node is unlocked if all previous nodes are completed (or it's the first)
  if (id === 1) return completedIds.includes(1) ? 'completed' : 'current';
  const prevCompleted = completedIds.includes(id - 1);
  if (prevCompleted) return 'current';
  return 'locked';
}

/* ============================================
   RENDER TREE
   ============================================ */
function renderTree() {
  const tree = document.getElementById('skill-tree');
  tree.innerHTML = '';
  const positions = ['center','left','right','center','left','right','center','left','right','center','left','right','center','center'];

  NODES.forEach((node, i) => {
    // Track label
    if (node.trackStart) {
      const label = document.createElement('div');
      label.className = 'track-label';
      label.innerHTML = `<span>${node.trackLabel}</span>`;
      tree.appendChild(label);
    }

    const state = getNodeState(node.id);
    const pos = positions[i] || 'center';

    const row = document.createElement('div');
    row.className = `node-row ${pos}`;
    row.id = `node-row-${node.id}`;

    row.innerHTML = `
      <div class="node ${state}" data-id="${node.id}" role="button" tabindex="${state !== 'locked' ? 0 : -1}" aria-label="${node.title}${state === 'locked' ? ' (locked)' : ''}">
        <span class="node-icon">${node.icon}</span>
        <span class="node-title">${node.title}</span>
      </div>
    `;

    tree.appendChild(row);
  });

  // Draw SVG connectors after DOM is updated
  requestAnimationFrame(() => {
    renderConnectors();
    // Re-observe new DOM nodes for scroll reveal
    reobserveNodes();
  });
}

/* ============================================
   SVG CONNECTORS
   ============================================ */
function renderConnectors() {
  const tree = document.getElementById('skill-tree');
  const isMobile = window.innerWidth <= 768;

  // Remove old SVG if exists
  const oldSvg = tree.querySelector('.connector-svg');
  if (oldSvg) oldSvg.remove();

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.classList.add('connector-svg');
  const treeRect = tree.getBoundingClientRect();
  svg.setAttribute('width', treeRect.width);
  svg.setAttribute('height', treeRect.height);
  svg.setAttribute('viewBox', `0 0 ${treeRect.width} ${treeRect.height}`);

  // Collect node center positions relative to the tree container
  const nodePositions = [];
  NODES.forEach((node) => {
    const nodeEl = tree.querySelector(`[data-id="${node.id}"]`);
    if (!nodeEl) return;
    const nodeRect = nodeEl.getBoundingClientRect();
    nodePositions.push({
      id: node.id,
      x: nodeRect.left - treeRect.left + nodeRect.width / 2,
      y: nodeRect.top - treeRect.top + nodeRect.height / 2,
      trackStart: node.trackStart
    });
  });

  // Draw paths between consecutive nodes
  for (let i = 1; i < nodePositions.length; i++) {
    const prev = nodePositions[i - 1];
    const curr = nodePositions[i];

    // Skip drawing across track boundaries (labels break the visual flow)
    // But still draw ‚Äî the track label is between them visually

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    if (isMobile || Math.abs(prev.x - curr.x) < 10) {
      // Straight vertical line
      path.setAttribute('d', `M ${prev.x} ${prev.y} L ${curr.x} ${curr.y}`);
    } else {
      // Smooth S-curve between zigzag nodes
      const midY = (prev.y + curr.y) / 2;
      path.setAttribute('d', 
        `M ${prev.x} ${prev.y} C ${prev.x} ${midY}, ${curr.x} ${midY}, ${curr.x} ${curr.y}`
      );
    }

    // Determine connector color state
    const prevState = getNodeState(NODES[i - 1].id);
    const currState = getNodeState(NODES[i].id);

    if (prevState === 'completed' && currState === 'completed') {
      path.classList.add('connector-completed');
    } else if (prevState === 'completed' || currState === 'completed' || currState === 'current') {
      path.classList.add('connector-active');
    }

    svg.appendChild(path);
  }

  // Insert SVG as first child so it's behind everything
  tree.insertBefore(svg, tree.firstChild);
}

// Redraw connectors on resize
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(renderConnectors, 100);
});

/* ============================================
   RENDER PROGRESS
   ============================================ */
function renderProgress() {
  const count = completedIds.length;
  const total = NODES.length;
  const pct = (count / total) * 100;

  document.getElementById('progress-count').textContent = `${count} / ${total}`;
  document.getElementById('progress-fill').style.width = `${pct}%`;

  // Completion banner
  const banner = document.getElementById('completion-banner');
  if (count >= total) {
    banner.classList.add('visible');
  } else {
    banner.classList.remove('visible');
  }
}

/* ============================================
   MODAL
   ============================================ */
function openModal(id) {
  const node = NODES.find(n => n.id === id);
  if (!node) return;
  const state = getNodeState(id);
  if (state === 'locked') return;

  currentModalId = id;

  document.getElementById('modal-icon').textContent = node.icon;
  document.getElementById('modal-title').textContent = node.title;
  document.getElementById('modal-track').textContent = node.trackLabel || '';

  document.getElementById('modal-summary').textContent = node.summary;

  // Learn more content
  const lmContent = document.getElementById('learn-more-content');
  lmContent.innerHTML = `
    <div class="learn-more-section">
      <h4>What it does</h4>
      ${node.details.what}
    </div>
    <div class="learn-more-section">
      <h4>How it works</h4>
      ${node.details.how}
    </div>
    <div class="learn-more-section">
      <h4>Why it matters</h4>
      ${node.details.why}
    </div>
  `;
  lmContent.classList.remove('expanded');
  document.getElementById('learn-more-toggle').classList.remove('expanded');

  // Button state
  const btn = document.getElementById('btn-complete');
  if (state === 'completed') {
    btn.textContent = 'Completed ‚úì';
    btn.className = 'btn-complete completed-btn';
    btn.disabled = true;
  } else {
    btn.innerHTML = 'Got it! ‚úì';
    btn.className = 'btn-complete';
    btn.disabled = false;
  }

  const backdrop = document.getElementById('modal-backdrop');
  backdrop.classList.remove('closing');
  backdrop.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeModal() {
  const backdrop = document.getElementById('modal-backdrop');
  backdrop.classList.add('closing');
  document.body.style.overflow = '';
  setTimeout(() => {
    backdrop.classList.remove('active', 'closing');
    currentModalId = null;
  }, 250);
}

function toggleDetails() {
  const content = document.getElementById('learn-more-content');
  const toggle = document.getElementById('learn-more-toggle');
  content.classList.toggle('expanded');
  toggle.classList.toggle('expanded');
}

/* ============================================
   COMPLETE NODE
   ============================================ */
function completeNode(id) {
  if (completedIds.includes(id)) return;

  completedIds.push(id);
  saveProgress();

  // Close modal
  closeModal();

  // Re-render
  setTimeout(() => {
    renderTree();
    renderProgress();

    // Sparkle effect on completed node
    createSparkles(id);

    // Unlock animation on next node
    const nextNode = document.querySelector(`.node[data-id="${id + 1}"]`);
    if (nextNode) {
      nextNode.classList.add('unlock-anim');
    }

    // Scroll to next node
    setTimeout(() => {
      const nextRow = document.getElementById(`node-row-${id + 1}`);
      if (nextRow) {
        nextRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, 400);

    // Check milestones
    checkMilestone(false);

    // Final completion
    if (completedIds.length >= NODES.length) {
      setTimeout(() => showConfetti(), 600);
    }
  }, 300);
}

/* ============================================
   SPARKLE EFFECT
   ============================================ */
function createSparkles(nodeId) {
  const nodeEl = document.querySelector(`.node[data-id="${nodeId}"]`);
  if (!nodeEl) return;

  const colors = ['#58a6ff', '#bc8cff', '#3fb950', '#d29922', '#f0f6fc'];
  
  for (let i = 0; i < 12; i++) {
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    const angle = (i / 12) * 360;
    const distance = 30 + Math.random() * 25;
    const tx = Math.cos(angle * Math.PI / 180) * distance;
    const ty = Math.sin(angle * Math.PI / 180) * distance;
    sparkle.style.cssText = `
      --tx: ${tx}px;
      --ty: ${ty}px;
      background: ${colors[i % colors.length]};
      left: 50%;
      top: 50%;
      margin-left: -3px;
      margin-top: -3px;
    `;
    nodeEl.appendChild(sparkle);
    setTimeout(() => sparkle.remove(), 800);
  }
}

/* ============================================
   MASCOT MESSAGES
   ============================================ */
function checkMilestone(initial) {
  const count = completedIds.length;
  const total = NODES.length;
  const pct = Math.round((count / total) * 100);

  if (initial && count === 0) return;
  if (initial && count > 0 && count < total) {
    showMascot(`Welcome back! You're <strong>${pct}%</strong> through. Keep going!`);
    return;
  }
  if (initial) return;

  if (count === 1) {
    showMascot(`First one down! <strong>${total - 1} to go.</strong> You're already ahead of most people who never read docs. üê¥`);
  } else if (pct >= 100) {
    showMascot(`<strong>YOU DID IT!</strong> You now know more about Hoofy than most horses know about hay. I'm proud of you. üèÜ`);
  } else if (pct >= 75) {
    showMascot(`<strong>${pct}%!</strong> You're in the home stretch! The finish line smells like victory (and oats). üê¥`);
  } else if (pct >= 50) {
    showMascot(`<strong>Halfway there!</strong> You know more about AI tooling than 90% of developers. No cap. üê¥`);
  } else if (pct >= 25) {
    showMascot(`<strong>${pct}% done!</strong> The foundations are solid. Now the fun stuff begins. üê¥`);
  }
}

function showMascot(msg) {
  const mascot = document.getElementById('mascot');
  document.getElementById('mascot-msg').innerHTML = msg;
  mascot.classList.add('visible');

  clearTimeout(mascotTimer);
  mascotTimer = setTimeout(() => {
    mascot.classList.remove('visible');
  }, 5000);
}

/* ============================================
   CONFETTI
   ============================================ */
function showConfetti() {
  const canvas = document.getElementById('confetti-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const particles = [];
  const colors = ['#58a6ff', '#bc8cff', '#3fb950', '#d29922', '#f85149', '#f0f6fc'];

  for (let i = 0; i < 150; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * -1,
      w: 4 + Math.random() * 8,
      h: 4 + Math.random() * 6,
      color: colors[Math.floor(Math.random() * colors.length)],
      vx: (Math.random() - 0.5) * 3,
      vy: 2 + Math.random() * 4,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 10,
      opacity: 1,
      decay: 0.003 + Math.random() * 0.005
    });
  }

  let running = true;

  function animate() {
    if (!running) { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let alive = 0;
    particles.forEach(p => {
      if (p.opacity <= 0) return;
      alive++;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.rot += p.rotV;
      p.opacity -= p.decay;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot * Math.PI / 180);
      ctx.globalAlpha = Math.max(0, p.opacity);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();
    });

    if (alive > 0) {
      requestAnimationFrame(animate);
    } else {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      running = false;
    }
  }

  animate();
  setTimeout(() => { running = false; }, 6000);
}

/* ============================================
   RESET
   ============================================ */
function resetProgress() {
  if (!confirm('Reset all progress? This cannot be undone.')) return;
  completedIds = [];
  saveProgress();
  renderTree();
  renderProgress();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

/* ============================================
   EVENT BINDING
   ============================================ */
function bindEvents() {
  // Node clicks (delegated)
  document.getElementById('skill-tree').addEventListener('click', (e) => {
    const node = e.target.closest('.node');
    if (!node) return;
    const id = parseInt(node.dataset.id);
    if (getNodeState(id) !== 'locked') openModal(id);
  });

  // Keyboard on nodes
  document.getElementById('skill-tree').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      const node = e.target.closest('.node');
      if (!node) return;
      e.preventDefault();
      const id = parseInt(node.dataset.id);
      if (getNodeState(id) !== 'locked') openModal(id);
    }
  });

  // Modal close
  document.getElementById('modal-close').addEventListener('click', closeModal);
  document.getElementById('modal-backdrop').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeModal();
  });

  // Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && currentModalId !== null) closeModal();
  });

  // Learn more toggle
  document.getElementById('learn-more-toggle').addEventListener('click', toggleDetails);

  // Complete button
  document.getElementById('btn-complete').addEventListener('click', () => {
    if (currentModalId !== null && !completedIds.includes(currentModalId)) {
      completeNode(currentModalId);
    }
  });

  // Reset
  document.getElementById('btn-reset').addEventListener('click', resetProgress);

  // Mascot dismiss on click
  document.getElementById('mascot').addEventListener('click', () => {
    document.getElementById('mascot').classList.remove('visible');
  });
}

/* ============================================
   AMBIENT PARTICLE SYSTEM
   ============================================ */
function initAmbientParticles() {
  const canvas = document.getElementById('ambient-canvas');
  const ctx = canvas.getContext('2d');
  const isMobile = window.innerWidth <= 768;
  const particleCount = isMobile ? 25 : 60;
  const particles = [];

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = document.documentElement.scrollHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  const colors = [
    { r: 88, g: 166, b: 255 },   // blue
    { r: 188, g: 140, b: 255 },   // purple
    { r: 63, g: 185, b: 80 },     // green
    { r: 210, g: 153, b: 34 },    // gold
  ];

  for (let i = 0; i < particleCount; i++) {
    const color = colors[Math.floor(Math.random() * colors.length)];
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      baseX: 0,
      baseY: 0,
      size: 1.5 + Math.random() * 3,
      speedX: (Math.random() - 0.5) * 0.3,
      speedY: -0.1 - Math.random() * 0.3,
      opacity: 0.1 + Math.random() * 0.25,
      pulseSpeed: 0.005 + Math.random() * 0.01,
      pulsePhase: Math.random() * Math.PI * 2,
      color: color
    });
  }

  let frame = 0;

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    frame++;

    // Adjust canvas height to match scrollable area
    const docHeight = document.documentElement.scrollHeight;
    if (canvas.height !== docHeight) {
      canvas.height = docHeight;
    }

    particles.forEach(p => {
      // Movement
      p.x += p.speedX;
      p.y += p.speedY;

      // Mouse repulsion (gentle push away)
      const scrollY = window.scrollY;
      const dx = p.x - mouseX;
      const dy = p.y - (mouseY + scrollY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 150 && dist > 0) {
        const force = (150 - dist) / 150 * 0.5;
        p.x += (dx / dist) * force;
        p.y += (dy / dist) * force;
      }

      // Wrap around
      if (p.y < -20) p.y = canvas.height + 20;
      if (p.y > canvas.height + 20) p.y = -20;
      if (p.x < -20) p.x = canvas.width + 20;
      if (p.x > canvas.width + 20) p.x = -20;

      // Pulse opacity
      const pulse = Math.sin(frame * p.pulseSpeed + p.pulsePhase);
      const alpha = p.opacity + pulse * 0.08;

      // Draw orb with glow
      const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
      gradient.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`);
      gradient.addColorStop(0.4, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.4})`);
      gradient.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    });

    requestAnimationFrame(animate);
  }

  animate();
}

/* ============================================
   SCROLL REVEAL (IntersectionObserver)
   ============================================ */
let scrollRevealObserver = null;

function initScrollReveal() {
  scrollRevealObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const delay = entry.target.classList.contains('track-label') ? 0 : 80;
        setTimeout(() => {
          entry.target.classList.add('revealed');
        }, delay);
        scrollRevealObserver.unobserve(entry.target);
      }
    });
  }, { threshold: 0.15, rootMargin: '0px 0px -30px 0px' });

  reobserveNodes();
}

/* Re-observe new DOM nodes after renderTree() recreates them */
function reobserveNodes() {
  if (!scrollRevealObserver) return;
  const viewportBottom = window.innerHeight + 50;
  document.querySelectorAll('.node-row, .track-label').forEach((el, i) => {
    if (el.classList.contains('revealed')) return; // already visible
    // Nodes already in viewport get revealed immediately (no stagger delay)
    const rect = el.getBoundingClientRect();
    if (rect.top < viewportBottom) {
      el.style.transitionDelay = '0ms';
      el.classList.add('revealed');
    } else {
      el.style.transitionDelay = `${i * 60}ms`;
      scrollRevealObserver.observe(el);
    }
  });
}

/* ============================================
   MOUSE PARALLAX & NODE TILT
   ============================================ */
function initMouseParallax() {
  // Track mouse globally
  document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  // 3D tilt effect on nodes
  const tree = document.getElementById('skill-tree');
  tree.addEventListener('mousemove', (e) => {
    const nodes = tree.querySelectorAll('.node:not(.locked)');
    nodes.forEach(node => {
      const rect = node.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const dx = e.clientX - centerX;
      const dy = e.clientY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 200) {
        const intensity = (200 - dist) / 200;
        const tiltX = (dy / 200) * 8 * intensity;
        const tiltY = -(dx / 200) * 8 * intensity;
        node.style.transform = `perspective(500px) rotateX(${tiltX}deg) rotateY(${tiltY}deg) scale(${1 + intensity * 0.05})`;
      } else {
        node.style.transform = '';
      }
    });
  });

  tree.addEventListener('mouseleave', () => {
    tree.querySelectorAll('.node').forEach(n => { n.style.transform = ''; });
  });

  // Hero parallax on mouse move
  const hero = document.querySelector('.hero');
  hero.addEventListener('mousemove', (e) => {
    const rect = hero.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width - 0.5;
    const y = (e.clientY - rect.top) / rect.height - 0.5;

    const icon = hero.querySelector('.hero-icon');
    if (icon) {
      icon.style.transform = `translateY(${-14 + y * -8}px) rotate(${x * 4}deg)`;
    }
  });

  hero.addEventListener('mouseleave', () => {
    const icon = hero.querySelector('.hero-icon');
    if (icon) icon.style.transform = '';
  });
}

/* ============================================
   HERO FLOATING SYMBOLS
   ============================================ */
function initHeroAmbient() {
  const container = document.getElementById('hero-ambient');
  if (!container) return;
  const symbols = ['‚ö°', 'üß†', 'üíæ', 'üîó', 'üìã', 'üõ°Ô∏è', '‚öôÔ∏è', 'üîç', 'üí°', '‚ú®'];

  function spawnSymbol() {
    const el = document.createElement('span');
    el.className = 'float-symbol';
    el.textContent = symbols[Math.floor(Math.random() * symbols.length)];
    el.style.left = `${10 + Math.random() * 80}%`;
    el.style.animationDuration = `${8 + Math.random() * 12}s`;
    el.style.animationDelay = `${Math.random() * 2}s`;
    el.style.fontSize = `${0.8 + Math.random() * 0.8}rem`;
    container.appendChild(el);

    // Remove after animation
    const dur = parseFloat(el.style.animationDuration) * 1000 + parseFloat(el.style.animationDelay) * 1000;
    setTimeout(() => el.remove(), dur);
  }

  // Spawn initial batch
  for (let i = 0; i < 6; i++) {
    setTimeout(spawnSymbol, i * 800);
  }

  // Keep spawning
  setInterval(spawnSymbol, 3000);
}

/* ============================================
   BOOT
   ============================================ */
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
