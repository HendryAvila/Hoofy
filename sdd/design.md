> ⚡ Auto-generated by sdd_reverse_engineer — review and refine as needed

# Hoofy — Technical Design

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/Hoofy) | Stage 4: Design

## Architecture Overview

## Architecture Overview

Hoofy follows a **Modular Monolith** architecture with **Clean Architecture** principles, packaged as a single static binary.

### Architectural Pattern
- **Composition Root** (`internal/server/server.go`): Single wiring point for all dependencies — constructor injection throughout.
- **Dependency Inversion**: Tools depend on interfaces (`config.Store`, `memory.Store`, `templates.Renderer`), never on concrete implementations.
- **Single Responsibility**: One file = one tool handler. Config handles persistence, pipeline handles business rules, tools handle MCP protocol translation.
- **Open/Closed**: New tools and stages can be added without modifying existing ones.

### Subsystem Interactions
Three independent subsystems communicate through shared interfaces:

```
┌──────────────────────────────────────────────────────────┐
│                    MCP Transport (stdio)                  │
├──────────────────────────────────────────────────────────┤
│                    server.go (Composition Root)           │
│                    Wires all dependencies                 │
├──────────────┬──────────────────┬────────────────────────┤
│  Project     │  Change          │  Memory                │
│  Pipeline    │  Pipeline        │  System                │
│  (8 stages)  │  (4-7 stages)    │  (SQLite + FTS5)       │
│              │                  │                        │
│  config.Store│  changes.Store   │  memory.Store          │
│  pipeline.*  │  changes.*       │  memtools.*            │
│  tools.*     │  tools.*         │                        │
├──────────────┴──────────────────┴────────────────────────┤
│                    Filesystem (sdd/)                      │
│                    SQLite DB (~/.hoofy/memory.db)         │
└──────────────────────────────────────────────────────────┘
```

### Key Design Decisions
- **Memory is optional**: If SQLite init fails, SDD tools still work — memory tools simply aren't registered.
- **Memory-SDD bridge**: When memory is available, stage completions automatically create memory observations for cross-session context.
- **Tools are dumb storage**: The AI client generates ALL content. Hoofy tools validate, persist, and advance state — never generate content themselves.
- **Server instructions**: `server.go` embeds detailed instructions telling the AI HOW to use each tool (what content to generate, what to read first, etc.).

## Tech Stack

- **Language**: Go 1.25 — static typing, excellent concurrency, single binary output, fast compilation
- **MCP SDK**: mcp-go v0.44.0 (Mark3Labs) — Go implementation of the Model Context Protocol
- **Database**: SQLite via modernc.org/sqlite — pure Go implementation, no CGO required, enables static binary compilation
- **Search**: FTS5 (SQLite extension) — full-text search with tokenization and ranking for memory search
- **CLI**: Standard library `os.Args` parsing — minimal, no framework needed for 3 commands
- **Templates**: Go `text/template` — built-in, no external dependency for artifact rendering
- **Build**: `make` + `go build` with ldflags for version injection
- **Release**: GoReleaser — cross-compilation for 6 platform targets (linux/darwin/windows × amd64/arm64)
- **CI/CD**: GitHub Actions — test, lint, build on push; GoReleaser on tag push
- **Linting**: golangci-lint — comprehensive Go linter aggregator

## Components

### ProjectPipeline (internal/config, internal/pipeline, internal/tools)
- **Responsibility**: 8-stage greenfield project specification workflow
- **Covers**: FR-002, FR-003, FR-004, FR-005, FR-006, FR-007
- **Key files**: `config/config.go` (types, Store interface), `pipeline/state.go` (state machine), `pipeline/clarity.go` (Clarity Gate)
- **Tools**: `sdd_init_project`, `sdd_create_proposal`, `sdd_generate_requirements`, `sdd_create_business_rules`, `sdd_clarify`, `sdd_create_design`, `sdd_create_tasks`, `sdd_validate`, `sdd_get_context`
- **Depends on**: config.Store, templates.Renderer, optionally memory.Store (for bridge)

### ChangePipeline (internal/changes, internal/tools)
- **Responsibility**: Adaptive change management with type×size flow selection
- **Covers**: FR-008, FR-009, FR-010, FR-011, FR-023, FR-024, FR-031
- **Key files**: `changes/types.go` (types, stages, ADR), `changes/flows.go` (FlowRegistry), `changes/store.go` (FileStore, archive)
- **Tools**: `sdd_change`, `sdd_context_check`, `sdd_change_advance`, `sdd_change_status`, `sdd_adr`
- **Depends on**: changes.Store, config.Store, optionally memory.Store

### MemorySystem (internal/memory, internal/memtools)
- **Responsibility**: Persistent cross-session knowledge with search, relations, and compaction
- **Covers**: FR-012 through FR-020, FR-027, FR-029, FR-030, FR-033
- **Key files**: `memory/store.go` (SQLiteStore, all types, migrations, CRUD)
- **Tools**: `mem_save`, `mem_search`, `mem_context`, `mem_timeline`, `mem_get_observation`, `mem_relate`, `mem_unrelate`, `mem_build_context`, `mem_session_start`, `mem_session_end`, `mem_session_summary`, `mem_stats`, `mem_save_prompt`, `mem_capture_passive`, `mem_delete`, `mem_update`, `mem_suggest_topic_key`, `mem_progress`, `mem_compact`
- **Depends on**: memory.Store (SQLiteStore concrete implementation)

### BootstrapBridge (internal/tools)
- **Responsibility**: Reverse-engineering existing projects and generating missing SDD artifacts
- **Covers**: FR-025, FR-026
- **Tools**: `sdd_reverse_engineer`, `sdd_bootstrap`
- **Depends on**: filesystem scanning, config.Store

### SelfUpdater (internal/updater)
- **Responsibility**: Check for and apply binary updates from GitHub Releases
- **Covers**: FR-021, FR-022
- **Key files**: `updater/updater.go`
- **Depends on**: GitHub Releases API, filesystem (atomic binary replacement)

### TemplateRenderer (internal/templates)
- **Responsibility**: Rendering stage artifacts with mode-specific templates (guided vs expert)
- **Covers**: FR-032
- **Key files**: `templates/` directory with `.tmpl` files
- **Depends on**: Go text/template

### CompositionRoot (internal/server)
- **Responsibility**: Wiring all dependencies, registering MCP tools/prompts/resources, embedding server instructions
- **Covers**: FR-001, FR-028
- **Key files**: `server/server.go`
- **Depends on**: All other components (this is the ONLY place with concrete type knowledge)

## API Contracts

_No API contracts defined — this project does not expose an API._

## Data Model

## Project Config (`sdd/sdd.json`)

| Field | Type | Description |
|-------|------|-------------|
| name | string | Project name |
| description | string | Brief project description |
| mode | string | "guided" or "expert" |
| created_at | datetime | Project initialization timestamp |
| stages | map[string]StageInfo | Stage name → status + completed_at |

### StageInfo
| Field | Type | Description |
|-------|------|-------------|
| status | string | "pending", "in_progress", "completed" |
| completed_at | datetime | When stage was completed (nullable) |

---

## Change State (`sdd/changes/<slug>/change.json`)

| Field | Type | Description |
|-------|------|-------------|
| id | string | Slugified change description |
| type | string | "feature", "fix", "refactor", "enhancement" |
| size | string | "small", "medium", "large" |
| description | string | Human-readable change description |
| status | string | "active", "completed", "abandoned" |
| current_stage | int | Index into the flow's stage list |
| stages | []StageStatus | Ordered list of stage statuses |
| adrs | []ADR | Architecture Decision Records |
| created_at | datetime | Change creation timestamp |
| completed_at | datetime | Change completion timestamp (nullable) |

---

## Memory Database (`~/.hoofy/memory.db`)

### observations
| Column | Type | Constraints |
|--------|------|-------------|
| id | INTEGER | PK, AUTOINCREMENT |
| session_id | TEXT | FK to sessions (nullable) |
| type | TEXT | NOT NULL (manual, decision, architecture, bugfix, pattern, config, discovery, learning, session_summary, prompt, progress) |
| title | TEXT | NOT NULL |
| content | TEXT | NOT NULL, max 2000 chars |
| scope | TEXT | DEFAULT 'project' (project, personal) |
| project | TEXT | Nullable |
| topic_key | TEXT | Nullable, for upsert semantics |
| namespace | TEXT | Nullable, for multi-agent isolation |
| content_hash | TEXT | Normalized hash for deduplication |
| created_at | DATETIME | NOT NULL |
| updated_at | DATETIME | NOT NULL |
| deleted_at | DATETIME | Nullable (soft delete) |

### observations_fts (FTS5 virtual table)
| Column | Type | Description |
|--------|------|-------------|
| title | TEXT | Indexed for full-text search |
| content | TEXT | Indexed for full-text search |

### sessions
| Column | Type | Constraints |
|--------|------|-------------|
| id | TEXT | PK |
| project | TEXT | Nullable |
| directory | TEXT | Nullable |
| started_at | DATETIME | NOT NULL |
| ended_at | DATETIME | Nullable |
| summary | TEXT | Nullable |

### relations
| Column | Type | Constraints |
|--------|------|-------------|
| id | INTEGER | PK, AUTOINCREMENT |
| from_id | INTEGER | FK to observations, NOT NULL |
| to_id | INTEGER | FK to observations, NOT NULL |
| relation_type | TEXT | NOT NULL |
| note | TEXT | Nullable |
| created_at | DATETIME | NOT NULL |

### prompts
| Column | Type | Constraints |
|--------|------|-------------|
| id | INTEGER | PK, AUTOINCREMENT |
| session_id | TEXT | FK to sessions (nullable) |
| content | TEXT | NOT NULL |
| project | TEXT | Nullable |
| namespace | TEXT | Nullable |
| created_at | DATETIME | NOT NULL |

## Infrastructure & Deployment

- **Distribution**: Single static binary — no runtime dependencies, no Docker needed
- **Platforms**: linux/amd64, linux/arm64, darwin/amd64, darwin/arm64, windows/amd64, windows/arm64
- **CI Pipeline** (GitHub Actions): `test (go test -race) → lint (golangci-lint) → build` on every push/PR to main
- **Release Pipeline** (GitHub Actions): GoReleaser triggered on tag push — builds 6 platform binaries, creates GitHub Release with checksums
- **Package Manager**: Homebrew tap updated automatically by GoReleaser
- **Self-Update**: `hoofy update` checks GitHub Releases API, downloads latest binary for current platform, atomically replaces itself
- **Data Storage**: SQLite DB at `~/.hoofy/memory.db` (auto-created on first use), project artifacts at `sdd/` in user's project directory
- **Version Management**: Injected at build time via `go build -ldflags "-X server.Version=<tag>"`

## Security Considerations

- **FTS5 Input Sanitization**: All user search queries are sanitized before passing to SQLite FTS5 MATCH to prevent syntax errors and injection attacks
- **Atomic Binary Updates**: Self-update writes to a temp file first, then performs an atomic rename to prevent binary corruption during update
- **No Network Listeners**: Hoofy only communicates via stdin/stdout (MCP stdio transport) — no open ports, no attack surface
- **Soft Delete**: Observations are soft-deleted (deleted_at timestamp) by default, with optional hard delete — prevents accidental data loss
- **No Secrets Handling**: Hoofy does not store credentials, API keys, or sensitive user data — memory content is user-controlled
- **Stderr for UI**: All diagnostic/progress output goes to stderr to prevent MCP protocol corruption on stdout

## Design Decisions

### ADR-001: Pure Go SQLite over CGO SQLite
**Context**: Need SQLite for memory persistence but want static binary compilation across all platforms.
**Decision**: Use modernc.org/sqlite (pure Go transpilation of SQLite) instead of mattn/go-sqlite3 (CGO-based).
**Rationale**: CGO_ENABLED=0 is required for static binaries and simple cross-compilation. Pure Go SQLite eliminates C compiler dependency.
**Alternatives rejected**: mattn/go-sqlite3 (requires CGO, complicates cross-compilation), BoltDB/BadgerDB (no SQL, no FTS5).

### ADR-002: Tools as Dumb Storage
**Context**: MCP tools could either generate content or simply store it.
**Decision**: Tools are storage-only — the AI client generates ALL content, tools validate, persist, and advance pipeline state.
**Rationale**: AI models are better at content generation. Keeping tools dumb makes them testable, predictable, and model-agnostic. Server instructions guide the AI on what to generate.
**Alternatives rejected**: Server-side content generation (ties to specific models, harder to test, less flexible).

### ADR-003: Stdio-Only MCP Transport
**Context**: MCP supports multiple transports (stdio, HTTP/SSE).
**Decision**: Support stdio transport only.
**Rationale**: Stdio is the simplest, most universal transport. Works with all MCP clients. No port management, no auth, no CORS. Single binary stays simple.
**Alternatives rejected**: HTTP transport (requires port management, auth, CORS — unnecessary complexity for a local development tool).

### ADR-004: Memory as Optional Subsystem
**Context**: Memory requires SQLite which could fail to initialize (permissions, disk space, etc.).
**Decision**: If memory initialization fails, SDD tools continue working — memory tools simply aren't registered.
**Rationale**: SDD pipeline is the core value proposition. Users shouldn't lose spec-driven development because of a memory DB issue.
**Alternatives rejected**: Hard fail on memory init (blocks all functionality), in-memory fallback (loses persistence, defeats purpose).

### ADR-005: Single Active Change Constraint
**Context**: Could allow multiple concurrent changes or restrict to one.
**Decision**: Only one active change at a time.
**Rationale**: Reduces cognitive complexity for both the AI and the user. Changes represent focused work — context switching between multiple active changes leads to quality degradation.
**Alternatives rejected**: Multiple concurrent changes (complex state management, confusing context, higher error rate).
