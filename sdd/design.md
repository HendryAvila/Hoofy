# SDD-Hoffy Adaptive Pipeline — Technical Design

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/sdd-hoffy) | Stage 4: Design

## Architecture Overview

## Architecture Pattern: Parallel Pipeline with Shared Infrastructure

The adaptive pipeline is a **parallel subsystem** alongside the existing project pipeline. Both share the same infrastructure (composition root, memory bridge, template renderer) but maintain separate state machines, separate persistence, and separate tool handlers.

```
┌─────────────────────────────────────────────────────────┐
│                    server.go (Composition Root)          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─── Project Pipeline ───┐   ┌── Change Pipeline ──┐  │
│  │  config.Store           │   │ changes.Store        │  │
│  │  pipeline.Advance()     │   │ changes.Advance()    │  │
│  │  tools/init,propose...  │   │ tools/change,adr...  │  │
│  │  sdd/sdd.json           │   │ sdd/changes/<id>/    │  │
│  └─────────────────────────┘   └──────────────────────┘  │
│                                                         │
│  ┌─── Shared Infrastructure ────────────────────────┐   │
│  │  templates.Renderer                               │   │
│  │  tools.StageObserver (MemoryBridge)               │   │
│  │  memory.Store                                     │   │
│  └───────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### Key Design Principles

1. **Independence**: Change pipeline operates without requiring `sdd/sdd.json` — if `sdd/` doesn't exist, it creates only `sdd/changes/`. Project pipeline tools never read change state; change tools never read project state.

2. **Reusable Stage Logic**: Change stages reuse the same *concepts* as project stages (propose, spec, clarify, design, tasks, verify) but with their own simplified handler logic within the tool handlers. No shared state machine — the change pipeline has its own `Advance()` function.

3. **Stage Flow Definitions**: Hardcoded in `internal/changes/flows.go` as a `map[ChangeType]map[ChangeSize][]ChangeStage`. The AI does not choose stages — the flow is deterministic based on (type, size).

4. **ADRs as Transversal Concept**: `sdd_adr` works at any point — with or without an active change. When a change is active, ADRs are linked to it. Always persisted to memory via topic_key upsert.

5. **One Active Change**: Enforced at the `sdd_change` tool level — returns error if active change exists. No database locks or complex concurrency — just a simple check in `changes.Store.GetActive()`.

## Tech Stack

- **Language**: Go 1.25 — same as existing codebase
- **MCP SDK**: `mcp-go v0.44.0` — same tool/prompt/resource patterns
- **Persistence**: JSON files (`change.json`) — consistent with existing `sdd.json` pattern, no new dependencies
- **Templates**: Go `text/template` via embedded filesystem — extends existing `templates.Renderer`
- **Memory**: Existing `internal/memory.Store` — ADRs saved via topic_key upserts
- **Testing**: `go test -cover` with `t.TempDir()` for filesystem isolation — same patterns as Phase 1
- **No new dependencies** — everything uses existing Go stdlib + mcp-go + memory (modernc.org/sqlite already embedded)

## Components

### ChangeStore (`internal/changes/store.go`)
- **Responsibility**: Persistence for change records (`change.json`). CRUD operations on change state.
- **Covers**: FR-001, FR-003, FR-005
- **Exposes**: `Store` interface with `Create()`, `Load()`, `LoadActive()`, `Save()`, `Archive()`, `List()`
- **Depends on**: Filesystem only (no external deps)
- **Interface**:
```go
type Store interface {
    Create(projectRoot string, change *ChangeRecord) error
    Load(projectRoot, changeID string) (*ChangeRecord, error)
    LoadActive(projectRoot string) (*ChangeRecord, error)
    Save(projectRoot string, change *ChangeRecord) error
    Archive(projectRoot, changeID string) error
    List(projectRoot string) ([]ChangeRecord, error)
}
```

### ChangeFlows (`internal/changes/flows.go`)
- **Responsibility**: Defines the stage flow for each (type, size) combination. Pure functions, no state.
- **Covers**: FR-002, FR-008, FR-011
- **Exposes**: `StageFlow(changeType, size) []ChangeStage`, constants for all flow definitions
- **Depends on**: Nothing (pure data + functions)

### ChangeStateMachine (`internal/changes/state.go`)
- **Responsibility**: State transitions for change pipeline — advance, validate transitions, mark stages.
- **Covers**: FR-004, FR-007
- **Exposes**: `Advance()`, `CanAdvance()`, `RequireStage()`, `CurrentStage()`
- **Depends on**: `ChangeRecord` type

### ChangeTypes (`internal/changes/types.go`)
- **Responsibility**: Type definitions for the change pipeline — `ChangeRecord`, `ChangeStage`, `ChangeType`, `ChangeSize`, `ADR`, enums
- **Covers**: FR-001 (types), all FRs (shared types)
- **Exposes**: All type definitions used across the changes package

### ChangeTool (`internal/tools/change.go`)
- **Responsibility**: MCP handler for `sdd_change` — creates a new change, selects stage flow, writes initial `change.json`
- **Covers**: FR-001, FR-002
- **Exposes**: `Definition()`, `Handle()`
- **Depends on**: `changes.Store`, `changes.StageFlow()`, `tools.StageObserver`

### ChangeAdvanceTool (`internal/tools/change_advance.go`)
- **Responsibility**: MCP handler for `sdd_change_advance` — saves stage content and advances to next stage
- **Covers**: FR-004, FR-007
- **Exposes**: `Definition()`, `Handle()`
- **Depends on**: `changes.Store`, `templates.Renderer`, `tools.StageObserver`
- **Note**: This is the workhorse tool — accepts stage content (like propose/spec/design content) and saves it as the artifact for the current stage, then advances. The AI generates content appropriate to the current stage.

### ChangeStatusTool (`internal/tools/change_status.go`)
- **Responsibility**: MCP handler for `sdd_change_status` — shows current change state, completed stages, remaining stages
- **Covers**: FR-005
- **Exposes**: `Definition()`, `Handle()`
- **Depends on**: `changes.Store`

### ADRTool (`internal/tools/adr.go`)
- **Responsibility**: MCP handler for `sdd_adr` — captures Architecture Decision Records, stores in change dir (if active) AND memory
- **Covers**: FR-006, FR-012
- **Exposes**: `Definition()`, `Handle()`
- **Depends on**: `changes.Store` (optional — works without active change), `memory.Store`

### ChangeBridge Extension (`internal/tools/bridge.go` — extended)
- **Responsibility**: Extended `StageObserver` or new `ChangeObserver` interface for auto-saving change stage completions to memory
- **Covers**: FR-010
- **Exposes**: `OnChangeStageComplete()` method added to bridge
- **Depends on**: `memory.Store`

### ServerWiring (`internal/server/server.go` — extended)
- **Responsibility**: Wire new change tools into the composition root
- **Covers**: All FRs (integration point)
- **Depends on**: All new tools + existing infrastructure

## API Contracts

### MCP Tool: `sdd_change`

Creates a new change and selects its stage flow.

**Parameters:**
| Param | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | enum | yes | `feature`, `fix`, `refactor`, `enhancement` |
| `size` | enum | yes | `small`, `medium`, `large` |
| `description` | string | yes | What this change does |

**Response:** Change record summary with selected stage flow, first stage marked in_progress.
**Error cases:** Active change already exists; invalid type/size.

---

### MCP Tool: `sdd_change_advance`

Saves stage content and advances the active change to its next stage.

**Parameters:**
| Param | Type | Required | Description |
|-------|------|----------|-------------|
| `content` | string | yes | The rendered content for the current stage (AI-generated) |
| `title` | string | no | Optional title/summary for the stage artifact |

**Response:** Stage completion confirmation, next stage info, or change completion if at verify.
**Error cases:** No active change; content empty.

**Behavior by current stage:**
- `describe` / `scope` / `propose`: Saves content as `<stage>.md`, advances
- `spec`: Saves content as `spec.md`, advances
- `clarify`: Saves content as `clarify.md`, advances (no score gate — change clarify is lighter than project clarify)
- `design`: Saves content as `design.md`, advances
- `tasks`: Saves content as `tasks.md`, advances
- `verify`: Saves content as `verify.md`, marks change as `completed`

---

### MCP Tool: `sdd_change_status`

Shows the current state of the active change (or a specific change by ID).

**Parameters:**
| Param | Type | Required | Description |
|-------|------|----------|-------------|
| `change_id` | string | no | Specific change ID to query. Omit for active change. |

**Response:** Formatted status with stage progress table, similar to `sdd_get_context`.
**Error cases:** No active change and no change_id provided; change_id not found.

---

### MCP Tool: `sdd_adr`

Captures an Architecture Decision Record.

**Parameters:**
| Param | Type | Required | Description |
|-------|------|----------|-------------|
| `title` | string | yes | Short ADR title (e.g., "Use PostgreSQL over MongoDB") |
| `context` | string | yes | Problem context that led to this decision |
| `decision` | string | yes | What was decided |
| `rationale` | string | yes | Why this decision was made |
| `alternatives_rejected` | string | no | What other options were considered and why rejected |
| `status` | enum | no | `proposed`, `accepted`, `deprecated`, `superseded`. Default: `accepted` |

**Response:** ADR saved confirmation with ID and storage locations.
**Behavior:**
- If active change exists: ADR saved to `sdd/changes/<id>/adrs/ADR-NNN.md` AND to memory
- If no active change: ADR saved to memory only (with project context from cwd)
- Memory storage: topic_key `adr/<project>/<adr-title-slug>`, type `decision`

## Data Model

### ChangeRecord (`change.json`)

```go
type ChangeRecord struct {
    ID          string       `json:"id"`           // slug: "fix-fts5-empty-query"
    Type        ChangeType   `json:"type"`         // feature | fix | refactor | enhancement
    Size        ChangeSize   `json:"size"`         // small | medium | large
    Description string       `json:"description"`  // free-text description
    Stages      []StageEntry `json:"stages"`       // ordered stage list with status
    CurrentStage string      `json:"current_stage"` // active stage name
    ADRs        []string     `json:"adrs"`         // ADR IDs captured during this change
    Status      ChangeStatus `json:"status"`       // active | completed | archived
    CreatedAt   string       `json:"created_at"`   // RFC3339
    UpdatedAt   string       `json:"updated_at"`   // RFC3339
}
```

### StageEntry (within ChangeRecord)

```go
type StageEntry struct {
    Name        ChangeStage `json:"name"`                    // describe | propose | scope | spec | clarify | design | tasks | verify
    Status      string      `json:"status"`                  // pending | in_progress | completed
    StartedAt   string      `json:"started_at,omitempty"`
    CompletedAt string      `json:"completed_at,omitempty"`
}
```

### ADR (Architecture Decision Record)

```go
type ADR struct {
    ID                 string   `json:"id"`                   // "ADR-001"
    Title              string   `json:"title"`                // "Use PostgreSQL over MongoDB"
    Context            string   `json:"context"`              // problem context
    Decision           string   `json:"decision"`             // what was decided
    Rationale          string   `json:"rationale"`            // why
    AlternativesRejected string `json:"alternatives_rejected"` // what else was considered
    Status             string   `json:"status"`               // proposed | accepted | deprecated | superseded
    ChangeID           string   `json:"change_id,omitempty"`  // linked change, if any
    CreatedAt          string   `json:"created_at"`           // RFC3339
}
```

### Enums

```go
type ChangeType string
const (
    TypeFeature     ChangeType = "feature"
    TypeFix         ChangeType = "fix"
    TypeRefactor    ChangeType = "refactor"
    TypeEnhancement ChangeType = "enhancement"
)

type ChangeSize string
const (
    SizeSmall  ChangeSize = "small"
    SizeMedium ChangeSize = "medium"
    SizeLarge  ChangeSize = "large"
)

type ChangeStage string
const (
    StageDescribe ChangeStage = "describe"  // lightweight: what's the change?
    StageScope    ChangeStage = "scope"     // refactor-specific: what changes, what doesn't
    StagePropose  ChangeStage = "propose"   // full proposal (reuses concept from project pipeline)
    StageSpec     ChangeStage = "spec"      // requirements/spec for the change
    StageClarify  ChangeStage = "clarify"   // clarity gate (only for large changes)
    StageDesign   ChangeStage = "design"    // technical design
    StageTasks    ChangeStage = "tasks"     // implementation task breakdown
    StageVerify   ChangeStage = "verify"    // final validation
)

type ChangeStatus string
const (
    StatusActive    ChangeStatus = "active"
    StatusCompleted ChangeStatus = "completed"
    StatusArchived  ChangeStatus = "archived"
)
```

### Directory Structure

```
sdd/
├── sdd.json                    # Project pipeline (unchanged)
├── changes/
│   ├── fix-fts5-empty-query/
│   │   ├── change.json         # Change record
│   │   ├── describe.md         # Stage artifact
│   │   ├── tasks.md            # Stage artifact
│   │   ├── verify.md           # Stage artifact
│   │   └── adrs/
│   │       └── ADR-001.md      # ADR captured during change
│   └── feature-adaptive-pipeline/
│       ├── change.json
│       ├── propose.md
│       ├── spec.md
│       ├── clarify.md
│       ├── design.md
│       ├── tasks.md
│       ├── verify.md
│       └── adrs/
├── history/                    # Archived changes (FR-009)
│   └── fix-fts5-empty-query/   # Moved from changes/ on archive
└── proposal.md                 # Project pipeline artifacts (unchanged)
```

## Infrastructure & Deployment

- **No infrastructure changes** — this is a pure code addition to an existing binary
- **CI/CD**: Existing GitHub Actions pipeline handles test → lint → build. New `internal/changes/` package is automatically picked up by `go test ./...`
- **Binary size**: Expected increase < 100KB (pure Go types + logic, no new dependencies). Well within the 1MB budget (NFR-003)
- **GoReleaser**: No changes needed — existing configuration builds all targets

## Security Considerations

- **No authentication/authorization changes** — SDD-Hoffy is a local CLI/MCP tool with no network exposure
- **File permissions**: Change directories and artifacts created with `0o755` (dirs) and `0o644` (files), consistent with existing patterns
- **Path traversal prevention**: Change IDs are slugified (alphanumeric + hyphens only), preventing directory traversal via malicious descriptions
- **No secrets in artifacts**: Change artifacts are markdown specs, not code — no risk of leaking credentials
- **Memory ADR content**: ADRs saved to memory follow the same sanitization as existing observations (FTS5 input sanitization already handles special characters)

## Design Decisions

### ADR-001: Separate `changes` Package vs Extending `config`

**Context**: The change pipeline needs its own types, store, and state machine. We could extend `config/` and `pipeline/` or create a new package.

**Decision**: New `internal/changes/` package with its own Store interface and state machine.

**Rationale**: 
- SRP: `config` handles project-level config; `changes` handles change-level config
- The change pipeline has fundamentally different semantics (dynamic stage flows vs fixed pipeline)
- Avoids bloating existing packages with conditionals
- Change types don't need to be aware of project pipeline types

**Alternatives rejected**: 
- Extending `config.ProjectConfig` with a `Changes` field — couples them unnecessarily
- Shared generic pipeline — over-abstraction for two slightly different state machines

---

### ADR-002: `sdd_change_advance` as Single Workhorse Tool vs Per-Stage Tools

**Context**: The project pipeline has separate tools per stage (`sdd_create_proposal`, `sdd_generate_requirements`, etc.). Should changes follow the same pattern?

**Decision**: Single `sdd_change_advance` tool that accepts generic `content` and saves it to whatever the current stage is.

**Rationale**:
- Changes have 8 possible stages across 12 flow variants — creating 8 separate tools is excessive
- The AI already knows what content to generate based on the current stage (reported by `sdd_change_status`)
- Reduces MCP tool count (4 new tools instead of 8+)
- The content format varies by stage, but the save-and-advance pattern is identical
- Server instructions tell the AI what content format each stage expects

**Alternatives rejected**:
- Per-stage tools (`sdd_change_propose`, `sdd_change_spec`, etc.) — too many tools, most are trivially similar
- Parameterized stage name on advance — error-prone, the tool should know what stage it's on

---

### ADR-003: No Clarity Gate Score on Change Pipeline

**Context**: The project pipeline has a strict Clarity Gate with weighted scores across 8 dimensions. Should changes reuse this?

**Decision**: Changes with a `clarify` stage use a simplified pass-through: the AI saves clarification content, but there's no score threshold. The stage just records that clarification was done.

**Rationale**:
- Only large features/enhancements have a clarify stage — these are already high-intent users
- The full 8-dimension analysis is overkill for a single feature change
- The AI still generates clarification Q&A — it's just not gated by a numeric score
- Simplifies implementation significantly (no ClarityDimension scoring for changes)
- If needed later, can add a lightweight score gate without breaking the interface

**Alternatives rejected**:
- Full Clarity Gate reuse — too heavyweight for change flows
- No clarify stage at all — large changes genuinely benefit from explicit ambiguity resolution

---

### ADR-004: ADR Memory Persistence via topic_key Upserts

**Context**: ADRs need to be searchable across sessions. How should they be stored in memory?

**Decision**: Each ADR is saved to memory with topic_key `adr/<project-slug>/<adr-title-slug>`. If the same ADR title is captured again (e.g., status change from proposed → accepted), the upsert overwrites the previous observation.

**Rationale**:
- Consistent with the existing bridge pattern (project pipeline uses `sdd/<project>/<stage>`)
- Natural deduplication — re-capturing an ADR updates rather than duplicates
- Searchable via `mem_search` with "adr" prefix
- Works whether the ADR is captured within a change or standalone

**Alternatives rejected**:
- Separate ADR table in SQLite — over-engineering, breaks the "memory is generic observations" model
- No memory persistence — ADRs would be trapped in change directories, not searchable cross-session

---

### ADR-005: Change ID as Description Slug

**Context**: Changes need unique IDs. Options: UUID, auto-increment, user-provided, or derived from description.

**Decision**: Auto-generate a slug from the description, e.g., "Fix FTS5 empty query crash" → `fix-fts5-empty-query-crash`. If slug already exists, append a numeric suffix: `fix-fts5-empty-query-crash-2`.

**Rationale**:
- Human-readable directory names (developer-friendly)
- Deterministic enough for single-developer workflows
- UUIDs are unreadable in directory names
- Consistent with how the user described the data model in clarifications

**Alternatives rejected**:
- UUID — unreadable directory names like `sdd/changes/a1b2c3d4-e5f6/`
- User-provided ID — one more required parameter, friction
- Timestamp-based — readable but not meaningful
