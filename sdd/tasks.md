# SDD-Hoffy Adaptive Pipeline â€” Implementation Tasks

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/sdd-hoffy) | Stage 5: Tasks

## Task Summary

**Total Tasks:** 10
**Estimated Effort:** 3-4 days for a single developer

---

## Tasks

### TASK-001: Create change types and enums (`internal/changes/types.go`)
**Component**: ChangeTypes
**Covers**: FR-001 (types)
**Dependencies**: None
**Description**: Define all type definitions for the change pipeline: `ChangeType`, `ChangeSize`, `ChangeStage`, `ChangeStatus` enums, `ChangeRecord`, `StageEntry`, and `ADR` structs. This is the foundation that all other change package files depend on. Include the `Slugify()` helper function for generating change IDs from descriptions.
**Acceptance Criteria**:
- [ ] All enum types defined with constants (ChangeType: 4 values, ChangeSize: 3, ChangeStage: 8, ChangeStatus: 3)
- [ ] `ChangeRecord` struct with all fields matching design data model
- [ ] `StageEntry` struct with name, status, timestamps
- [ ] `ADR` struct with all fields
- [ ] `Slugify(description string) string` function: lowercases, replaces spaces with hyphens, removes non-alphanumeric except hyphens, truncates to 50 chars
- [ ] Unit tests for `Slugify()` with edge cases (empty, special chars, long strings, unicode)
- [ ] `ValidateType()` and `ValidateSize()` functions that return error for invalid values

---

### TASK-002: Create stage flow definitions (`internal/changes/flows.go`)
**Component**: ChangeFlows
**Covers**: FR-002, FR-008, FR-011
**Dependencies**: TASK-001
**Description**: Define the 12 hardcoded stage flows as a nested map `FlowRegistry[ChangeType][ChangeSize][]ChangeStage`. Expose a `StageFlow(changeType, size)` function that returns the ordered stage list. All 12 flows from the clarification answers:
- fix: small(describeâ†’tasksâ†’verify), medium(describeâ†’specâ†’tasksâ†’verify), large(describeâ†’specâ†’designâ†’tasksâ†’verify)
- feature: small(describeâ†’tasksâ†’verify), medium(proposeâ†’specâ†’tasksâ†’verify), large(proposeâ†’specâ†’clarifyâ†’designâ†’tasksâ†’verify)
- refactor: small(scopeâ†’tasksâ†’verify), medium(scopeâ†’designâ†’tasksâ†’verify), large(scopeâ†’specâ†’designâ†’tasksâ†’verify)
- enhancement: small(describeâ†’tasksâ†’verify), medium(proposeâ†’specâ†’tasksâ†’verify), large(proposeâ†’specâ†’clarifyâ†’designâ†’tasksâ†’verify)
**Acceptance Criteria**:
- [ ] `FlowRegistry` variable with all 12 (type, size) combinations
- [ ] `StageFlow(t ChangeType, s ChangeSize) ([]ChangeStage, error)` returns correct stages
- [ ] Returns error for invalid type/size combinations
- [ ] Unit tests verifying all 12 flows match the clarification spec exactly
- [ ] `StageFilename(stage ChangeStage) string` maps stage names to artifact filenames (`describe.md`, `spec.md`, etc.)

---

### TASK-003: Create change store (`internal/changes/store.go`)
**Component**: ChangeStore
**Covers**: FR-001, FR-003, FR-005
**Dependencies**: TASK-001
**Description**: Implement `FileStore` (concrete) implementing the `Store` interface for change record persistence. Operations: `Create()` creates `sdd/changes/<id>/` directory and writes `change.json`; `Load()` reads a specific change; `LoadActive()` scans all changes for `status: active`; `Save()` updates `change.json`; `List()` returns all changes. `Archive()` moves from `sdd/changes/` to `sdd/history/`. Handle slug collisions in `Create()` by appending numeric suffix.
**Acceptance Criteria**:
- [ ] `Store` interface defined with all 6 methods
- [ ] `FileStore` struct implementing `Store`
- [ ] `Create()` creates directory structure, writes `change.json`, handles slug collisions
- [ ] `Load()` reads and parses `change.json` by change ID
- [ ] `LoadActive()` returns the active change or nil if none
- [ ] `Save()` writes updated `change.json` with `updated_at` timestamp
- [ ] `Archive()` moves change dir from `changes/` to `history/`, sets status to `archived`
- [ ] `List()` returns all changes (active + completed + archived)
- [ ] All tests use `t.TempDir()` for filesystem isolation
- [ ] â‰¥80% code coverage

---

### TASK-004: Create change state machine (`internal/changes/state.go`)
**Component**: ChangeStateMachine
**Covers**: FR-004, FR-007
**Dependencies**: TASK-001, TASK-002
**Description**: Implement state transitions for the change pipeline. Unlike the project pipeline (fixed stage order), the change pipeline reads stage order from `ChangeRecord.Stages`. `Advance()` marks current stage completed, moves to next. `CanAdvance()` checks we're not at the last stage. For `verify` stage (final), mark change as `completed`. Include injectable time function for deterministic testing, matching the pattern in `pipeline/time.go`.
**Acceptance Criteria**:
- [ ] `Advance(change *ChangeRecord) error` â€” marks current completed, moves to next
- [ ] `CanAdvance(change *ChangeRecord) error` â€” validates transition is possible
- [ ] `CurrentStageIndex(change *ChangeRecord) int` â€” returns ordinal of current stage
- [ ] `IsLastStage(change *ChangeRecord) bool` â€” true if current stage is verify
- [ ] When advancing past final stage, set `change.Status = StatusCompleted`
- [ ] Injectable `timeNow` for testing (same pattern as `pipeline/time.go`)
- [ ] Unit tests for all transitions including edge cases (already completed, unknown stage)

---

### TASK-005: Create `sdd_change` tool handler (`internal/tools/change.go`)
**Component**: ChangeTool
**Covers**: FR-001, FR-002
**Dependencies**: TASK-001, TASK-002, TASK-003
**Description**: MCP handler for `sdd_change` â€” creates a new change. Validates type/size, checks no active change exists via `changes.Store.LoadActive()`, generates slug from description, looks up stage flow, creates `ChangeRecord` with first stage marked `in_progress`, saves via store. Returns formatted response with change summary and stage flow.
**Acceptance Criteria**:
- [ ] MCP tool definition with `type` (enum), `size` (enum), `description` (required string)
- [ ] Validates all required parameters
- [ ] Returns error if active change already exists (with active change ID in message)
- [ ] Generates slug from description using `Slugify()`
- [ ] Looks up stage flow via `changes.StageFlow()`
- [ ] Creates `ChangeRecord` with correct initial state (first stage in_progress)
- [ ] Saves via `changes.Store.Create()`
- [ ] Returns formatted response showing change ID, type, size, and stage flow
- [ ] Does NOT require `sdd/sdd.json` to exist (pipeline independence)
- [ ] Notifies bridge if available

---

### TASK-006: Create `sdd_change_advance` tool handler (`internal/tools/change_advance.go`)
**Component**: ChangeAdvanceTool
**Covers**: FR-004, FR-007
**Dependencies**: TASK-003, TASK-004
**Description**: MCP handler for `sdd_change_advance` â€” the workhorse tool. Loads active change, saves content as `<current_stage>.md` in the change directory, advances the state machine. If current stage is `verify`, marks change as completed. Notifies bridge for memory persistence.
**Acceptance Criteria**:
- [ ] MCP tool definition with `content` (required string), `title` (optional string)
- [ ] Returns error if no active change
- [ ] Returns error if content is empty
- [ ] Saves content to `sdd/changes/<id>/<stage>.md`
- [ ] Calls `changes.Advance()` to move to next stage
- [ ] Updates `change.json` via `changes.Store.Save()`
- [ ] When `verify` stage completes, marks change status as `completed`
- [ ] Returns formatted response with completed stage name and next stage (or completion message)
- [ ] Notifies bridge (change observer) if available
- [ ] Uses `writeStageFile()` helper for consistent file writing

---

### TASK-007: Create `sdd_change_status` tool handler (`internal/tools/change_status.go`)
**Component**: ChangeStatusTool
**Covers**: FR-005
**Dependencies**: TASK-003
**Description**: MCP handler for `sdd_change_status` â€” shows current change state. If `change_id` is provided, loads that specific change. Otherwise, loads the active change. Returns formatted status with stage progress table (similar to `sdd_get_context` output style).
**Acceptance Criteria**:
- [ ] MCP tool definition with optional `change_id` parameter
- [ ] Returns error if no active change and no change_id provided
- [ ] Returns error if change_id is provided but not found
- [ ] Formatted output includes: change ID, type, size, description, status
- [ ] Stage progress table with checkmarks (âœ…/ğŸ”„/â¬œ) matching `sdd_get_context` style
- [ ] Lists ADRs captured during the change (if any)
- [ ] Shows artifact file sizes for completed stages

---

### TASK-008: Create `sdd_adr` tool handler (`internal/tools/adr.go`)
**Component**: ADRTool
**Covers**: FR-006, FR-012
**Dependencies**: TASK-001, TASK-003
**Description**: MCP handler for `sdd_adr` â€” captures Architecture Decision Records. Works with or without active change. If active change: saves ADR as `sdd/changes/<id>/adrs/ADR-NNN.md` (auto-numbering) AND to memory. If no active change: saves to memory only. ADR format: Context, Decision, Rationale, Alternatives Rejected, Status. Uses `normalizeProject()` from bridge.go for topic_key generation.
**Acceptance Criteria**:
- [ ] MCP tool definition with `title`, `context`, `decision`, `rationale` (required), `alternatives_rejected`, `status` (optional)
- [ ] Default status is `accepted`
- [ ] Valid status values: `proposed`, `accepted`, `deprecated`, `superseded`
- [ ] With active change: saves `ADR-NNN.md` in `adrs/` subdirectory, adds ADR ID to `change.ADRs`, saves change record
- [ ] Auto-numbers ADRs: `ADR-001`, `ADR-002`, etc. (based on existing count in change)
- [ ] Without active change: saves to memory only (no error, graceful handling)
- [ ] Memory persistence: topic_key `adr/<project-slug>/<title-slug>`, type `decision`
- [ ] Returns confirmation with ADR ID and storage locations

---

### TASK-009: Extend bridge and wire into server (`internal/tools/bridge.go` + `internal/server/server.go`)
**Component**: ChangeBridge, ServerWiring
**Covers**: FR-010, all FRs (integration)
**Dependencies**: TASK-005, TASK-006, TASK-007, TASK-008
**Description**: Add `ChangeObserver` interface to bridge.go with `OnChangeStageComplete(changeID string, stage changes.ChangeStage, content string)`. Extend `MemoryBridge` to implement it (topic_key: `change/<project>/<change-id>/<stage>`). Wire all 4 new tools into `server.go` composition root. Update `serverInstructions()` with change pipeline documentation.
**Acceptance Criteria**:
- [ ] `ChangeObserver` interface defined in bridge.go
- [ ] `MemoryBridge` implements `ChangeObserver`
- [ ] topic_key format: `change/<project-slug>/<change-id>/<stage>`
- [ ] `notifyChangeObserver()` nil-safe helper function
- [ ] All 4 new tools registered in `server.go`
- [ ] `changes.FileStore` created in `server.go` and injected into tools
- [ ] Bridge wired to change tools (same SetBridge pattern as existing tools)
- [ ] `serverInstructions()` updated with adaptive pipeline documentation
- [ ] Server boots with all new tools registered (verified by test)

---

### TASK-010: Integration tests and coverage verification
**Component**: All
**Covers**: NFR-002, NFR-006
**Dependencies**: TASK-009
**Description**: End-to-end integration tests that exercise the complete change flow: create change â†’ advance through all stages â†’ verify completion. Test multiple flow variants (fix/small with 3 stages, feature/large with 6 stages). Verify ADR capture both with and without active change. Verify existing SDD pipeline tests still pass (no regression). Verify â‰¥80% coverage on new code.
**Acceptance Criteria**:
- [ ] Integration test: fix/small flow (3 stages: describe â†’ tasks â†’ verify)
- [ ] Integration test: feature/large flow (6 stages: propose â†’ spec â†’ clarify â†’ design â†’ tasks â†’ verify)
- [ ] Integration test: ADR with active change (saved to file + memory)
- [ ] Integration test: ADR without active change (saved to memory only)
- [ ] Integration test: concurrent change rejection (create â†’ create â†’ error)
- [ ] Integration test: change archive (complete â†’ archive â†’ verify moved to history/)
- [ ] All existing tests pass (`go test ./...`)
- [ ] New code coverage â‰¥ 80% (checked via `go test -cover ./internal/changes/...`)
- [ ] golangci-lint passes with 0 issues

## Dependency Graph

```
TASK-001 (types)
â”œâ”€â”€ TASK-002 (flows) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€ TASK-003 (store)               â”‚
â”‚   â”œâ”€â”€ TASK-005 (sdd_change) â†â”€â”€â”€â”€â”˜
â”‚   â”œâ”€â”€ TASK-006 (sdd_change_advance)
â”‚   â”œâ”€â”€ TASK-007 (sdd_change_status)
â”‚   â””â”€â”€ TASK-008 (sdd_adr)
â”œâ”€â”€ TASK-004 (state machine) â† TASK-002
â”‚   â””â”€â”€ TASK-006 (sdd_change_advance) â† also depends on TASK-003
â”‚
TASK-005 + TASK-006 + TASK-007 + TASK-008
â””â”€â”€ TASK-009 (bridge + server wiring)
    â””â”€â”€ TASK-010 (integration tests)
```

**Parallelization opportunities:**
- TASK-002 and TASK-003 can be done in parallel (both depend only on TASK-001)
- TASK-005, TASK-007, and TASK-008 can be done in parallel (all depend on TASK-003, but TASK-005 also needs TASK-002)
- TASK-006 must wait for both TASK-003 and TASK-004
- TASK-009 must wait for all tool handlers (TASK-005 through TASK-008)
- TASK-010 must wait for everything (integration tests)

## Acceptance Criteria

- All code must pass `golangci-lint` with zero issues (errcheck strictly enforced)
- Test coverage for new `internal/changes/` package must be â‰¥ 80%
- All existing tests must continue passing (`go test ./...` â€” zero regressions)
- Binary size increase must be under 1MB (NFR-003)
- Binary must build with `CGO_ENABLED=0` (pure Go, no C dependencies)
- All `defer rows.Close()` / `Close()` patterns must use `defer func() { _ = x.Close() }()` for errcheck
- All tool return values (`AddObservation`, etc.) must be checked in tests
- Change artifacts must be human-readable markdown
- Every functional requirement (FR-001 through FR-012) must be traceable to at least one task
- Conventional commits format for all commits
