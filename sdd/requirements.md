# SDD-Hoffy Adaptive Pipeline — Requirements

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/sdd-hoffy) | Stage 2: Specify

## Functional Requirements

### Must Have

- **FR-001**: `sdd_change` tool — accepts change type (feature, fix, refactor, enhancement), size (small, medium, large), and description. Creates a change record in `sdd/changes/`
- **FR-002**: Adaptive stage selection — based on change type + size, automatically determines which pipeline stages to run (e.g., small fix = describe → tasks → verify; large feature = propose → spec → clarify → design → tasks → verify)
- **FR-003**: Change-scoped artifacts — each change produces its own set of markdown artifacts (proposal, spec, design, tasks) in a change-specific directory under `sdd/changes/<change-id>/`
- **FR-004**: `sdd_change_advance` tool — advances the active change to its next stage, similar to how the existing pipeline works but for the adaptive flow
- **FR-005**: `sdd_change_status` tool — shows current change state, completed stages, remaining stages, and artifact summary
- **FR-006**: ADR capture tool (`sdd_adr`) — captures an Architecture Decision Record at any point during a change flow. Stores in change directory AND persists to memory via topic_key upsert
- **FR-007**: Change verification — final stage of every change flow validates that all required artifacts were produced and are consistent
- **FR-008**: Stage flow definitions — hardcoded stage sequences per (type, size) combination, reusing existing stage logic where possible

### Should Have

- **FR-009**: Change archival — when a change is completed and verified, move its artifacts to `sdd/history/<change-id>/` with timestamp
- **FR-010**: Change-to-memory bridge — automatically save a summary of each completed change stage to persistent memory (extend existing StageObserver pattern)
- **FR-011**: Multiple stage definitions per type — support different sizes within the same type (e.g., feature/small vs feature/large have different stage flows)

### Could Have

- **FR-012**: `sdd_adr` standalone tool for capturing ADRs outside of a change flow
- **FR-013**: Change templates — pre-configured descriptions for common change patterns (e.g., "add API endpoint", "fix database query")
- **FR-014**: Change history summary — `sdd_get_context` shows recent changes alongside project pipeline status
- **FR-015**: Auto-size detection — infer change size from description length and complexity keywords

### Won't Have (this version)

- **FR-W01**: Concurrent changes — only one active change at a time per project
- **FR-W02**: Automatic size detection from code analysis — user must declare size or we infer from description length only
- **FR-W03**: Web UI or dashboard for change tracking
- **FR-W04**: Integration with external issue trackers (Jira, GitHub Issues, Linear)

## Non-Functional Requirements

- **NFR-001**: Small change (fix/small, enhancement/small) must complete setup in under 2 seconds (tool response time)
- **NFR-002**: No regression on existing SDD pipeline — all current tests must continue passing
- **NFR-003**: Binary size increase must be under 1MB from adding adaptive pipeline
- **NFR-004**: Change artifacts must be human-readable markdown, consistent with existing SDD artifact format
- **NFR-005**: ADRs must be searchable via `mem_search` within 100ms
- **NFR-006**: Code coverage for new adaptive pipeline code must be ≥ 80%

## Constraints

- Must work with `CGO_ENABLED=0` (pure Go, no C dependencies)
- Binary must remain under 30MB
- Must maintain backward compatibility with existing SDD tools and memory tools
- Go 1.25 + `mcp-go v0.44.0` — same tech stack
- Follows existing architecture: SRP per file, DI via composition root, tools are dumb storage

## Assumptions

- The existing SDD pipeline (`sdd_init_project` through `sdd_validate`) remains unchanged
- Memory subsystem (Phase 1) is available and working
- Changes operate within a single project directory
- The AI (LLM) generates content; tools are storage/pipeline handlers
- One active change at a time per project

## Dependencies

- `internal/memory` — Store for ADR persistence and change memory
- `internal/config` — Stage definitions, pipeline state machine
- `internal/pipeline` — Stage transitions, advancement logic
- `internal/server` — Composition root for wiring new tools
- `internal/tools/bridge.go` — StageObserver for auto-saving change artifacts to memory
