# SDD-Hoffy Memory Fusion — Technical Design

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/sdd-hoffy) | Stage 4: Design

## Architecture Overview

A modular monolith extending SDD-Hoffy's existing Clean Architecture with two new packages. The current architecture (tools → pipeline/config → filesystem) remains untouched. A new parallel path (memtools → memory.Store → SQLite) handles all memory operations. The only bridge point is in `server.go` (composition root), which wires the memory store into both memory tools AND optionally into SDD tools for auto-save on stage completion.

**Architecture Layers:**
1. **MCP Transport** (unchanged) — stdio via mcp-go SDK
2. **Tool Handlers** — existing `internal/tools/` (SDD) + new `internal/memtools/` (memory)
3. **Business Logic** — existing `internal/pipeline/` + `internal/config/` (SDD) + new `internal/memory/` (memory store)
4. **Persistence** — existing filesystem (`sdd/sdd.json` + markdown) + new SQLite (`~/.sdd-hoffy/memory.db`)

**Key Design Principle:** SDD and Memory are independent subsystems that share only the composition root. SDD tools NEVER depend on the memory store being available. Memory tools NEVER depend on the SDD pipeline state. This ensures:
- Zero regression risk for existing SDD functionality
- Memory DB failures don't break the SDD pipeline
- Each subsystem can be tested in isolation

## Tech Stack

- **Language**: Go 1.25 (unchanged)
- **MCP SDK**: mcp-go v0.44.0 (unchanged)
- **SQLite**: modernc.org/sqlite v1.45+ — pure Go implementation, FTS5 support, CGO_ENABLED=0 compatible
- **Build**: GoReleaser (unchanged) — static binaries for linux/darwin/windows × amd64/arm64
- **Testing**: stdlib `testing` + `t.TempDir()` for DB isolation (unchanged pattern)
- **CLI**: stdlib `flag` package (unchanged)

## Components

### MemoryStore (internal/memory/)
- **Responsibility**: SQLite database lifecycle (open/close/migrate), CRUD for observations and sessions, FTS5 search, topic_key upserts, deduplication, content hashing
- **Covers**: FR-001, FR-010, FR-011, FR-013
- **Exposes**: `Store` interface with methods: `SaveObservation`, `SearchObservations`, `GetObservation`, `GetRecentContext`, `GetTimeline`, `SaveSession`, `EndSession`, `GetStats`, `DeleteObservation`, `UpdateObservation`, `SuggestTopicKey`
- **Depends on**: modernc.org/sqlite
- **Pattern**: Adapted from Engram's `store.go` with interface extraction for testability

### MemTools — Save (internal/memtools/save.go)
- **Responsibility**: Handle `mem_save` and `mem_save_prompt` MCP tool calls
- **Covers**: FR-002, FR-014
- **Depends on**: memory.Store interface

### MemTools — Search (internal/memtools/search.go)
- **Responsibility**: Handle `mem_search` MCP tool call with FTS5 queries and filters
- **Covers**: FR-003
- **Depends on**: memory.Store interface

### MemTools — Context (internal/memtools/context.go)
- **Responsibility**: Handle `mem_context` tool — retrieve recent project observations
- **Covers**: FR-004
- **Depends on**: memory.Store interface

### MemTools — Session (internal/memtools/session.go)
- **Responsibility**: Handle `mem_session_start`, `mem_session_end`, `mem_session_summary` tools
- **Covers**: FR-005, FR-006
- **Depends on**: memory.Store interface

### MemTools — Timeline (internal/memtools/timeline.go)
- **Responsibility**: Handle `mem_timeline` and `mem_get_observation` tools — progressive disclosure
- **Covers**: FR-007, FR-008
- **Depends on**: memory.Store interface

### MemTools — Stats (internal/memtools/stats.go)
- **Responsibility**: Handle `mem_stats` tool
- **Covers**: FR-009
- **Depends on**: memory.Store interface

### MemTools — Manage (internal/memtools/manage.go)
- **Responsibility**: Handle `mem_delete`, `mem_update`, `mem_suggest_topic_key` tools
- **Covers**: FR-015, FR-016, FR-017
- **Depends on**: memory.Store interface

### SDD-Memory Bridge (internal/tools/bridge.go)
- **Responsibility**: Optional hook called after SDD stage completion to auto-save a compact summary to memory
- **Covers**: FR-018
- **Depends on**: memory.Store interface (optional — nil means no bridge)
- **Pattern**: Observer/hook pattern — existing tools call `bridge.OnStageComplete(stage, content)` if bridge is non-nil

### Enhanced SDD Context (modification to internal/tools/context.go)
- **Responsibility**: Add `detail_level` parameter to `sdd_get_context` for progressive disclosure
- **Covers**: FR-019
- **Depends on**: existing config.Store

### Server Composition Root (internal/server/server.go)
- **Responsibility**: Wire memory store + all memory tools + bridge into the MCP server. Updated server instructions with memory protocol.
- **Covers**: FR-020 (memory protocol in server instructions)
- **Depends on**: All tool packages, memory.Store

## API Contracts

All tools communicate via MCP protocol (JSON-RPC over stdio). Each tool receives `mcp.CallToolRequest` and returns `*mcp.CallToolResult`.

### mem_save
```json
// Input
{"title": "string", "content": "string (required)", "type": "string", "project": "string", "scope": "project|personal", "session_id": "string", "topic_key": "string"}
// Output: markdown confirmation with observation ID
```

### mem_search
```json
// Input
{"query": "string (required)", "project": "string", "type": "string", "scope": "project|personal", "limit": "number (default 10, max 20)"}
// Output: markdown list of matching observations with ID, title, snippet, score
```

### mem_context
```json
// Input
{"project": "string", "scope": "project|personal", "limit": "number (default 20)"}
// Output: markdown list of recent observations + recent sessions
```

### mem_session_start
```json
// Input
{"id": "string (required)", "project": "string", "directory": "string"}
// Output: confirmation with session ID
```

### mem_session_end
```json
// Input
{"id": "string (required)", "summary": "string"}
// Output: confirmation
```

### mem_session_summary
```json
// Input
{"content": "string (required)", "project": "string", "session_id": "string"}
// Output: confirmation with observation ID
```

### mem_timeline
```json
// Input
{"observation_id": "number (required)", "before": "number (default 5)", "after": "number (default 5)"}
// Output: chronological list of observations around the focus point
```

### mem_get_observation
```json
// Input
{"id": "number (required)"}
// Output: full observation content (untruncated)
```

### mem_stats
```json
// Input: none
// Output: markdown with total sessions, observations, projects, observations by type
```

### mem_save_prompt
```json
// Input
{"content": "string (required)", "project": "string", "session_id": "string"}
// Output: confirmation
```

### mem_delete
```json
// Input
{"id": "number (required)", "hard_delete": "boolean (default false)"}
// Output: confirmation (soft or hard delete)
```

### mem_update
```json
// Input
{"id": "number (required)", "title": "string", "content": "string", "type": "string", "project": "string", "scope": "string", "topic_key": "string"}
// Output: confirmation with updated fields
```

### mem_suggest_topic_key
```json
// Input
{"title": "string", "content": "string", "type": "string"}
// Output: suggested topic_key string (normalized)
```


## Data Model

### Observation
| Field | Type | Constraints |
|-------|------|-------------|
| id | INTEGER | PK, AUTOINCREMENT |
| session_id | TEXT | FK to sessions.id, nullable |
| title | TEXT | nullable |
| content | TEXT | NOT NULL |
| type | TEXT | DEFAULT 'manual' — values: manual, decision, architecture, bugfix, pattern, config, discovery, learning, tool_use, file_change, command, file_read, search, session_summary |
| project | TEXT | nullable, indexed |
| scope | TEXT | DEFAULT 'project' — values: project, personal |
| topic_key | TEXT | nullable, indexed — normalized lowercase, used for upserts |
| content_hash | TEXT | nullable, indexed — SHA256 of title+content for dedup |
| is_deleted | BOOLEAN | DEFAULT FALSE, indexed — soft delete flag |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP |
| updated_at | DATETIME | DEFAULT CURRENT_TIMESTAMP |

### Session
| Field | Type | Constraints |
|-------|------|-------------|
| id | TEXT | PK — user-provided or UUID |
| project | TEXT | nullable |
| directory | TEXT | nullable |
| started_at | DATETIME | DEFAULT CURRENT_TIMESTAMP |
| ended_at | DATETIME | nullable |
| summary | TEXT | nullable |

### observations_fts (FTS5 Virtual Table)
- Content table: observations
- Indexed columns: title, content
- Tokenizer: unicode61 (default FTS5 tokenizer)

### Indexes
- `idx_observations_project` ON observations(project)
- `idx_observations_session` ON observations(session_id)
- `idx_observations_topic` ON observations(topic_key)
- `idx_observations_hash` ON observations(content_hash)
- `idx_observations_deleted` ON observations(is_deleted)
- `idx_observations_type` ON observations(type)
- `idx_observations_created` ON observations(created_at DESC)

### Deduplication Logic
Content hash = SHA256(normalize(title) + "||" + normalize(content))
Window = 15 minutes — same hash within window is rejected (returns existing observation)

## Infrastructure & Deployment

- **Binary distribution**: GoReleaser (unchanged) — builds for linux/darwin/windows × amd64/arm64
- **CI/CD**: GitHub Actions (unchanged) — test → lint → build on push/PR. Release on tag.
- **New CI concern**: Tests that create SQLite DBs use `t.TempDir()` — no persistent state in CI
- **DB location**: `~/.sdd-hoffy/memory.db` with auto-creation
- **No containers needed**: Single static binary, no external services
- **Self-update**: Existing updater system (unchanged) — checks GitHub Releases API

## Security Considerations

- **Local-only storage**: All memory data stays on user's machine at `~/.sdd-hoffy/memory.db` — no network transmission
- **File permissions**: DB directory created with 0700, DB file created with 0600 (owner-only access)
- **No encryption at rest**: Acceptable for v1 — this is a local dev tool, not handling PII or secrets
- **SQL injection prevention**: All queries use parameterized statements (Go `database/sql` enforces this)
- **FTS5 input sanitization**: User search queries are sanitized before passing to FTS5 MATCH (wrap terms in quotes, escape special chars) — adapted from Engram's proven `sanitizeFTS()` function
- **Soft delete by default**: `mem_delete` marks `is_deleted=true` — data recoverable. Hard delete requires explicit flag.
- **No auth/authz**: Single-user local tool — no authentication needed

## Design Decisions

### ADR-001: modernc.org/sqlite over mattn/go-sqlite3
**Context**: Need SQLite with FTS5 support in a CGO_ENABLED=0 build
**Decision**: modernc.org/sqlite (pure Go transpilation of SQLite C code)
**Rationale**: Maintains static binary builds across all platforms. Proven in production by Engram.
**Alternatives rejected**: mattn/go-sqlite3 (requires CGO), embedded key-value stores like bbolt (no FTS5)

### ADR-002: Embed (copy+adapt) over Import as dependency
**Context**: Need Engram's store logic in SDD-Hoffy
**Decision**: Copy Engram's store.go and adapt it, extracting an interface
**Rationale**: Avoids coupling to Engram's release cycle, allows removing features we don't need (TUI, HTTP, Git Sync), lets us add SDD-specific features. Both are MIT licensed.
**Alternatives rejected**: Go module import (tight coupling, brings unwanted deps), full rewrite (wastes proven code)

### ADR-003: Independent subsystems with shared composition root
**Context**: How should SDD and Memory interact?
**Decision**: Two fully independent subsystems wired together only in server.go
**Rationale**: Zero regression risk — SDD tools don't know about memory, memory tools don't know about SDD pipeline. Bridge is optional (nil-safe). Each subsystem testable in isolation.
**Alternatives rejected**: Deep integration (SDD tools call memory directly — creates coupling and regression risk)

### ADR-004: Single global DB over per-project DBs
**Context**: Where to store memory data?
**Decision**: Single DB at `~/.sdd-hoffy/memory.db` with project field for filtering
**Rationale**: Enables cross-project search, simpler backup, single connection management. Engram uses this pattern successfully.
**Alternatives rejected**: Per-project DB in `sdd/` directory (can't search across projects, accidental git commits)

### ADR-005: Optional bridge pattern for SDD→Memory auto-save
**Context**: How should SDD stage completion trigger memory saves?
**Decision**: Observer/hook pattern — bridge is an optional dependency injected into SDD tools
**Rationale**: SDD tools remain testable without memory. Bridge can be nil (no-op). Clean separation of concerns.
**Alternatives rejected**: Event bus (overengineered for 7 events), direct calls (tight coupling)
