# SDD-Hoffy Memory Fusion — Implementation Tasks

> Generated by [SDD-Hoffy](https://github.com/HendryAvila/sdd-hoffy) | Stage 5: Tasks

## Task Summary

**Total Tasks:** 13
**Estimated Effort:** 5-7 days for a single developer. Broken down:
- Phase 1 (Foundation): TASK-001 + TASK-002 = 1.5 days
- Phase 2 (Core Tools): TASK-003 through TASK-008 = 2 days (parallelizable)
- Phase 3 (Wiring): TASK-009 = 0.5 days
- Phase 4 (Integration): TASK-010 + TASK-011 + TASK-012 = 1 day
- Phase 5 (Validation): TASK-013 = 0.5-1 day

---

## Tasks

### TASK-001: Add modernc.org/sqlite dependency
**Component**: ProjectSetup
**Covers**: FR-001 (partial), NFR-001
**Dependencies**: None
**Description**: Add `modernc.org/sqlite` to `go.mod` and verify the project builds with CGO_ENABLED=0. Create a minimal smoke test that opens an in-memory SQLite DB with FTS5 enabled to confirm the dependency works correctly across platforms.
**Acceptance Criteria**:
- [ ] `go.mod` includes `modernc.org/sqlite` v1.45+
- [ ] `CGO_ENABLED=0 go build ./...` succeeds
- [ ] Smoke test opens SQLite DB, creates FTS5 table, inserts and searches — passes
- [ ] All existing tests still pass
- [ ] `make lint` passes

---

### TASK-002: Implement memory store (internal/memory/)
**Component**: MemoryStore
**Covers**: FR-001, FR-010, FR-011, FR-013
**Dependencies**: TASK-001
**Description**: Create `internal/memory/` package with types (`Observation`, `Session`, `Stats`), `Store` interface, and `SQLiteStore` implementation. Adapt from Engram's `store.go` — include schema creation (observations, sessions, observations_fts), CRUD operations, FTS5 search with sanitization, topic_key upserts, content hash deduplication (SHA256 + 15min window), and WAL mode. DB auto-creates at specified path with proper file permissions.

Key methods on the Store interface:
- `Open(dbPath string) error`
- `Close() error`
- `SaveObservation(obs *Observation) (*Observation, error)`
- `GetObservation(id int64) (*Observation, error)`
- `SearchObservations(query string, filters SearchFilters) ([]ObservationResult, error)`
- `GetRecentContext(project string, scope string, limit int) ([]Observation, []Session, error)`
- `GetTimeline(observationID int64, before, after int) ([]Observation, error)`
- `StartSession(session *Session) error`
- `EndSession(id string, summary string) error`
- `GetStats() (*Stats, error)`
- `DeleteObservation(id int64, hard bool) error`
- `UpdateObservation(id int64, updates ObservationUpdate) (*Observation, error)`
- `SuggestTopicKey(title, content, obsType string) string`

**Acceptance Criteria**:
- [ ] `Store` interface defined with all methods
- [ ] `SQLiteStore` implements `Store`
- [ ] Schema creates observations, sessions, observations_fts tables with all indexes
- [ ] FTS5 search works with sanitized queries (special chars don't crash)
- [ ] Topic key upserts work: same topic_key updates existing observation
- [ ] Deduplication works: same content within 15min returns existing observation
- [ ] WAL mode enabled, busy timeout set to 5s
- [ ] DB directory auto-created with 0700, file with 0600 permissions
- [ ] Tests use `t.TempDir()` for isolation — ≥ 80% coverage
- [ ] Tests pass with race detector (`-race`)

---

### TASK-003: Implement mem_save and mem_search tools
**Component**: MemTools — Save, MemTools — Search
**Covers**: FR-002, FR-003
**Dependencies**: TASK-002
**Description**: Create `internal/memtools/save.go` and `internal/memtools/search.go`. Each file defines a struct with `memory.Store` dependency, `Definition()` returning `mcp.Tool` with proper parameter schemas, and `Handle()` implementing the MCP tool handler. `mem_save` accepts title, content (required), type, project, scope, session_id, topic_key. `mem_search` accepts query (required), project, type, scope, limit (default 10, max 20). Both return markdown-formatted responses.
**Acceptance Criteria**:
- [ ] `mem_save` saves observation with all optional fields
- [ ] `mem_save` with topic_key triggers upsert behavior
- [ ] `mem_save` returns markdown with observation ID
- [ ] `mem_search` performs FTS5 search with filters
- [ ] `mem_search` respects limit parameter (default 10, max 20)
- [ ] `mem_search` returns markdown list with ID, title, snippet, type
- [ ] Error cases return clear error messages
- [ ] Tests with ≥ 80% coverage

---

### TASK-004: Implement mem_context, mem_timeline, mem_get_observation tools
**Component**: MemTools — Context, MemTools — Timeline
**Covers**: FR-004, FR-007, FR-008
**Dependencies**: TASK-002
**Description**: Create `internal/memtools/context.go` and `internal/memtools/timeline.go`. `mem_context` retrieves recent observations for a project with optional scope filter. `mem_timeline` shows chronological context around a specific observation (progressive disclosure). `mem_get_observation` returns full untruncated content of a single observation by ID.
**Acceptance Criteria**:
- [ ] `mem_context` returns recent observations grouped by session
- [ ] `mem_context` supports project and scope filters
- [ ] `mem_timeline` shows N observations before and after a focus observation
- [ ] `mem_get_observation` returns full observation content by ID
- [ ] All return markdown-formatted responses
- [ ] Tests with ≥ 80% coverage

---

### TASK-005: Implement session lifecycle tools
**Component**: MemTools — Session
**Covers**: FR-005, FR-006
**Dependencies**: TASK-002
**Description**: Create `internal/memtools/session.go`. Implements `mem_session_start` (create session with id, project, directory), `mem_session_end` (close session with optional summary), and `mem_session_summary` (save structured summary as a session_summary observation with the expected format: Goal/Instructions/Discoveries/Accomplished/Files).
**Acceptance Criteria**:
- [ ] `mem_session_start` creates a new session record
- [ ] `mem_session_end` sets ended_at timestamp and optional summary
- [ ] `mem_session_summary` saves observation with type="session_summary"
- [ ] Session lifecycle works: start → save observations → summary → end
- [ ] Duplicate session start returns clear error
- [ ] Tests with ≥ 80% coverage

---

### TASK-006: Implement mem_stats tool
**Component**: MemTools — Stats
**Covers**: FR-009
**Dependencies**: TASK-002
**Description**: Create `internal/memtools/stats.go`. Returns total sessions, total observations, total projects, observations by type, and active sessions count. Formatted as markdown.
**Acceptance Criteria**:
- [ ] Returns accurate counts for sessions, observations, projects
- [ ] Shows breakdown by observation type
- [ ] Shows count of active (not ended) sessions
- [ ] Empty DB returns zeros, not errors
- [ ] Tests with ≥ 80% coverage

---

### TASK-007: Implement mem_delete, mem_update, mem_suggest_topic_key tools
**Component**: MemTools — Manage
**Covers**: FR-015, FR-016, FR-017
**Dependencies**: TASK-002
**Description**: Create `internal/memtools/manage.go`. `mem_delete` soft-deletes by default (sets is_deleted=true), with optional hard_delete flag for permanent removal. `mem_update` updates specific fields of an observation by ID (partial update — only provided fields change). `mem_suggest_topic_key` generates a normalized, stable topic key from title/content/type (lowercase, slash-separated path like "architecture/auth-model").
**Acceptance Criteria**:
- [ ] `mem_delete` soft-deletes by default
- [ ] `mem_delete` with hard_delete=true permanently removes the record
- [ ] `mem_delete` on non-existent ID returns clear error
- [ ] `mem_update` updates only provided fields
- [ ] `mem_update` updates updated_at timestamp
- [ ] `mem_suggest_topic_key` returns normalized lowercase slug
- [ ] Tests with ≥ 80% coverage

---

### TASK-008: Implement mem_save_prompt tool
**Component**: MemTools — Save
**Covers**: FR-014
**Dependencies**: TASK-002
**Description**: Add `mem_save_prompt` handler to `internal/memtools/save.go` (or a separate file if save.go gets too large). Saves user prompts with type="user_prompt", creating an observation that captures the user's intent for cross-session reference.
**Acceptance Criteria**:
- [ ] `mem_save_prompt` saves with type="user_prompt"
- [ ] Content field is required
- [ ] Project and session_id are optional
- [ ] Returns confirmation with observation ID
- [ ] Tests with ≥ 80% coverage

---

### TASK-009: Wire memory tools into MCP server (server.go)
**Component**: Server Composition Root
**Covers**: FR-012 (regression check), FR-020 (partial)
**Dependencies**: TASK-003, TASK-004, TASK-005, TASK-006, TASK-007, TASK-008
**Description**: Update `internal/server/server.go` to: (1) Initialize memory store on startup with DB path `~/.sdd-hoffy/memory.db`, (2) Create all memory tool instances with the store, (3) Register all memory tools with the MCP server, (4) Add graceful shutdown for the memory store (close DB on server exit). Ensure all existing SDD tools remain registered and functional.
**Acceptance Criteria**:
- [ ] Memory store opens on server startup
- [ ] All ~13 memory tools are registered
- [ ] All 8 existing SDD tools still registered and working
- [ ] Graceful shutdown closes memory DB
- [ ] If memory DB fails to open, server still starts (SDD tools work, memory tools return errors)
- [ ] All existing tests pass without modification

---

### TASK-010: Implement SDD-Memory bridge
**Component**: SDD-Memory Bridge
**Covers**: FR-018
**Dependencies**: TASK-009
**Description**: Create `internal/tools/bridge.go` with a `Bridge` struct that accepts `memory.Store`. Implements `OnStageComplete(projectName, stage, content string)` which saves a compact summary of the stage artifact to memory using topic_key upserts (e.g., topic_key="sdd/{project}/{stage}"). Modify existing SDD tool handlers to call the bridge after successful stage completion (nil-safe — if bridge is nil, no-op). Bridge is injected via server.go.
**Acceptance Criteria**:
- [ ] Bridge saves compact summary on stage completion
- [ ] Uses topic_key upserts so each stage has one evolving observation
- [ ] Bridge is nil-safe — existing tools work with nil bridge
- [ ] All existing SDD tests pass without modification
- [ ] Bridge tested in isolation with mock memory store
- [ ] Integration test: run SDD init → propose → verify observation exists in memory

---

### TASK-011: Enhanced sdd_get_context with detail_level
**Component**: Enhanced SDD Context
**Covers**: FR-019
**Dependencies**: TASK-009
**Description**: Modify `internal/tools/context.go` to add optional `detail_level` parameter to `sdd_get_context` tool. Values: "summary" (stage names + status only), "standard" (current behavior — default), "full" (include complete artifact content). This implements progressive disclosure for the SDD pipeline context.
**Acceptance Criteria**:
- [ ] `detail_level=summary` returns minimal stage status overview
- [ ] `detail_level=standard` (or omitted) returns current behavior exactly
- [ ] `detail_level=full` returns all artifact content inline
- [ ] Backward compatible — no parameter = same output as before
- [ ] Existing context tests pass without modification
- [ ] New tests for summary and full modes

---

### TASK-012: Memory protocol in server instructions
**Component**: Server Composition Root
**Covers**: FR-020
**Dependencies**: TASK-009
**Description**: Update the MCP server instructions in `server.go` to include the memory protocol — guidance for AI agents on WHEN to save memories (after architectural decisions, bug fixes, new patterns, config changes, discoveries), WHAT format to use (**What**/**Why**/**Where**/**Learned**), and WHEN to search (start of session, before making architectural decisions, when encountering familiar errors). Adapted from Engram's memory protocol.
**Acceptance Criteria**:
- [ ] Server instructions include memory protocol section
- [ ] Protocol covers: when to save, content format, when to search, session lifecycle
- [ ] Existing SDD instructions preserved
- [ ] Protocol is concise (minimal token usage — context engineering principle)

---

### TASK-013: Integration tests and final validation
**Component**: All
**Covers**: FR-012, NFR-003, NFR-006
**Dependencies**: TASK-010, TASK-011, TASK-012
**Description**: Run the full test suite, verify coverage targets, run lint, build with CGO_ENABLED=0, and perform end-to-end validation. Create integration tests that exercise: (1) full session lifecycle (start → save → search → timeline → summary → end), (2) SDD pipeline with bridge (init → propose → verify memory observation), (3) FTS5 search with edge cases (special chars, empty query, unicode). Verify binary size.
**Acceptance Criteria**:
- [ ] All existing tests pass (`make test`)
- [ ] New memory code has ≥ 80% coverage
- [ ] `make lint` passes with zero warnings
- [ ] `CGO_ENABLED=0 go build ./...` succeeds
- [ ] Binary size under 30MB
- [ ] Integration tests for full session lifecycle pass
- [ ] Integration test for SDD bridge passes
- [ ] FTS5 edge case tests pass (special chars, unicode, empty queries)

## Dependency Graph

TASK-001 (go.mod + SQLite dep)
  → TASK-002 (memory store + types + interface)
    → TASK-003 (mem_save + mem_search tools)
    → TASK-004 (mem_context + mem_timeline + mem_get_observation tools)
    → TASK-005 (mem_session_start/end/summary tools)
    → TASK-006 (mem_stats tool)
    → TASK-007 (mem_delete + mem_update + mem_suggest_topic_key tools)
    → TASK-008 (mem_save_prompt tool)
  TASK-003..008 → TASK-009 (server.go wiring — all memory tools registered)
  TASK-009 → TASK-010 (SDD-Memory bridge)
  TASK-009 → TASK-011 (enhanced sdd_get_context)
  TASK-009 → TASK-012 (memory protocol in server instructions)
  TASK-010..012 → TASK-013 (integration tests + final validation)

Parallelizable: TASK-003 through TASK-008 (all depend only on TASK-002)
Sequential: TASK-001 → TASK-002 → [TASK-003..008] → TASK-009 → [TASK-010..012] → TASK-013

## Acceptance Criteria

- All existing SDD-Hoffy tests pass with zero modifications
- New memory code has ≥ 80% test coverage
- Binary compiles with CGO_ENABLED=0 on all platforms
- `make test` passes with race detector enabled
- `make lint` passes with zero warnings
- Each task produces a working, testable increment
