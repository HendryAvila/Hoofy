# Shared rendering functions over pipeline bypass for reverse engineer

**Status:** accepted

## Context

The reverse engineer tool needs to write the same 3 SDD artifacts (business-rules.md, design.md, requirements.md) that the pipeline tools write. But pipeline tools have stage guards (pipeline.RequireStage) and depend on sdd.json — neither of which exist when reverse engineering an existing project.

## Decision

Extract artifact rendering+writing logic from sdd_generate_requirements, sdd_create_business_rules, and sdd_create_design into shared functions. Pipeline tools become thin wrappers: validate stage → call shared function → advance pipeline. The reverse engineer flow calls the shared functions directly without stage validation.

## Rationale

Extraction (A2) preserves SRP in pipeline tools — they stay clean without conditional bypass logic. The shared functions are DRY (single template rendering path for each artifact). This pattern is also forward-compatible: any future tool that needs to write SDD artifacts can use the same shared functions.

## Alternatives Rejected

A1 (bypass_pipeline parameter): Would add conditional logic (`if bypass { skip stage check }`) to 3 tools that are currently clean and simple. Violates OCP — every new bypass scenario would require modifying existing tools. Option D (new sdd_write_artifact tool): Would duplicate template rendering logic, creating two paths to generate the same artifacts — maintenance burden and potential format drift.
